//@ts-check
import { PrimitiveSet } from '../../utils/Primitives.js'
import { getRequire } from '../../utils/Runtime.js'
import { RuntimeName } from '../../utils/RuntimeName.js'
import { Activator } from '../Activator.js'
import { ActivatorDetails } from '../ActivatorDetails.js'
import { InvocationContext } from '../InvocationContext.js'
import { JavaTypeParsingFunctions } from './typeParsingFunctions/JavaTypeParsingFunctions.js'
import { NetcoreTypeParsingFunctions } from './typeParsingFunctions/NetcoreTypeParsingFunctions.js'
import { NodejsTypeParsingFunctions } from './typeParsingFunctions/NodejsTypeParsingFunctions.js'
import { PythonTypeParsingFunctions } from './typeParsingFunctions/PythonTypeParsingFunctions.js'

const dynamicImport = getRequire(import.meta.url)

/**
 * @typedef {import('../../types.d.ts').RuntimeName} RuntimeName
 */

/** @type {Map<number, Map<string, Function>>} */
const typeParsingFunctions = new Map([
    [RuntimeName.Netcore, NetcoreTypeParsingFunctions],
    [RuntimeName.Jvm, JavaTypeParsingFunctions],
    [RuntimeName.Nodejs, NodejsTypeParsingFunctions],
    [RuntimeName.Python, PythonTypeParsingFunctions],
    [RuntimeName.Python27, PythonTypeParsingFunctions],
])

class ComplexTypeResolver {
    /** @type {Map<string, ActivatorDetails>} */
    #typeMap
    
    constructor() {
        this.#typeMap = new Map()
    }
    
    /**
     * Register a custom type mapping
     * @param {string} resultType - The type name from the target runtime
     * @param {Function} type - The JavaScript constructor function
     * @param {any[]} [args] - Default arguments for the constructor
     */
    register(resultType, type, args) {
        if (!this.#typeMap.has(resultType)) {
            this.#typeMap.set(resultType, new ActivatorDetails(type, args))
        }
    }

    /**
     * Convert InvocationContext result to appropriate JavaScript type
     * @param {InvocationContext} ic - The invocation context
     * @returns {Promise<any>} The converted result
     */
    async convertResult(ic) {
        const runtimeName = ic.getRuntimeName()
        const resultType = await ic.getResultType()

        if (!resultType) {
            throw new Error('resultType is not valid')
        }

        let underlyingType = ComplexTypeResolver.tryGetUnderlyingArrayType(resultType)
        if (underlyingType !== null) {
            const { Type } = /** @type {ActivatorDetails} */ (this.#typeMap.get(underlyingType))

            const complexTypesArray = await ic.retrieveArray()
            return complexTypesArray.map((item) => Activator.createInstance(Type, item))
        }

        const parsingFunction = ComplexTypeResolver.tryGetTypeParsingFunction(runtimeName, resultType)
        if (parsingFunction) {
            return parsingFunction(ic)
        }

        const activatorDetails = this.tryGetValueFromTypeMap(resultType)
        if (!activatorDetails) {
            throw new Error(`No type registered for key '${resultType}'.`)
        }
        
        // For nodejs inmemory, getValue() returns the actual JS object
        if (runtimeName === RuntimeName.Nodejs) {
            const value = await ic.getValue()
            if (value) {
                // If it's already an instance of the registered type, return it directly
                if (value instanceof activatorDetails.Type) {
                    return value
                }
            }
        }
        
        // Create new instance with stored default arguments
        return Activator.createInstance(activatorDetails.Type, activatorDetails.arguments ?? null)
    }

    /**
     * Resolve type from string name and optional module
     * @param {string} typeName - Name of the type to resolve
     * @param {string} [moduleName] - Optional module name to import from
     * @returns {Function} The resolved type/constructor function
     */
    static resolveType(typeName, moduleName) {
        if (moduleName) {
            try {
                const module = dynamicImport(moduleName)
                const typeObj = module[typeName]
                if (!typeObj) {
                    throw new Error(`Type '${typeName}' not found in module '${moduleName}'`)
                }
                return typeObj
            } catch (error) {
                throw new Error(
                    `Failed to resolve type '${typeName}' from module '${moduleName}': ${/** @type {Error} */ (error).message}`
                )
            }
        }

        // Try to resolve from global scope
        const globalScope =
            typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {}

        const typeObj = /** @type {Record<string, any>} */ (globalScope)[typeName]
        if (!typeObj) {
            throw new Error(`Type '${typeName}' not found in global scope`)
        }
        return typeObj
    }

    /**
     * Attempts to extract the underlying element type from an array type string
     * @param {string} type - The type string to parse (e.g., "MyType[]")
     * @returns {string | null} Object indicating success and the element type
     * @throws {Error} If the array element type is a primitive type
     */
    static tryGetUnderlyingArrayType(type) {
        // Validate input type
        if (typeof type !== 'string' || !type.includes('[')) {
            return null
        }

        let trimmedType = type.trim()
        if (!trimmedType) return null

        // If assembly-qualified, remove everything after the first comma
        const commaIndex = trimmedType.indexOf(',')
        if (commaIndex > 0) {
            trimmedType = trimmedType.substring(0, commaIndex).trim()
        }

        // Find the first '[' â€” everything before it is the base type
        const bracketIndex = trimmedType.indexOf('[')
        if (bracketIndex > 0) {
            trimmedType = trimmedType.substring(0, bracketIndex).trim()
        }

        // Check if base type is a primitive (primitives are not supported as array elements)
        if (PrimitiveSet.has(trimmedType)) {
            throw new Error('Primitive array element types are not supported.')
        }

        return trimmedType
    }

    /**
     * @param {RuntimeName} runtimeName
     * @param {string} resultType
     * @returns {any}
     */
    static tryGetTypeParsingFunction(runtimeName, resultType) {
        const runtimeDict = typeParsingFunctions.get(runtimeName)
        return runtimeDict ? (runtimeDict.get(resultType) ?? null) : null
    }

    /**
     * @param {string} resultType
     * @returns {ActivatorDetails | null}
     */
    tryGetValueFromTypeMap(resultType) {
        if (!resultType) {
            throw new Error('resultType is not valid')
        }
        return this.#typeMap.get(resultType) ?? null
    }
}
export { ComplexTypeResolver }
