// @ts-check
import { Command } from '../utils/Command.js'
import { CommandType } from '../utils/CommandType.js'
import { InvocationContext } from './InvocationContext.js'
import { ConnectionType } from '../utils/ConnectionType.js'
import { ExceptionThrower } from '../utils/exception/ExceptionThrower.js'
import { RuntimeName } from '../utils/RuntimeName.js'
import { Interpreter } from '../core/interpreter/Interpreter.js'
import { delegatesCacheInstance } from '../core/delegatesCache/DelegatesCache.js'
import { TypesHandler } from '../utils/TypesHandler.js'
import { UtilsConst } from '../utils/UtilsConst.js'
import { Config } from "./configuration/Config.js"
import { getRequire, isNodejsRuntime } from '../utils/Runtime.js'


/**
 * @typedef {import('../types.d.ts').RuntimeName} RuntimeNameType
 * @typedef {import('../utils/connectionData/IConnectionData.js').IConnectionData} IConnectionData
 * @typedef {typeof import('../core/transmitter/Transmitter.js').Transmitter} Transmitter
 */

/** @type {typeof import('../core/transmitter/Transmitter.js').Transmitter | null} */
let _Transmitter = null

const requireDynamic = getRequire(import.meta.url)

/**
 * Represents a single context which allows interaction with a selected technology.
 * Refers to a single instance of the called runtime within a particular target OS process.
 * This can be either the local currently running process (inMemory) or a particular remote process identified by the IP Address and PORT of the target Javonet instance.
 * Multiple Runtime Contexts can be initialized within one process.
 * Calling the same technology on inMemory communication channel will return the existing instance of runtime context.
 * Calling the same technology on TCP channel but on different nodes will result in unique Runtime Contexts.
 * Within the runtime context, any number of libraries can be loaded and any objects from the target technology can be interacted with, as they are aware of each other due to sharing the same memory space and same runtime instance.
 * @see [Javonet Guides]{@link https://www.javonet.com/guides/v2/javascript/foundations/runtime-context}
 * @class
 */
class RuntimeContext {
    /** @type {Map<string, RuntimeContext>} */
    static memoryRuntimeContexts = new Map()
    /** @type {Map<string, RuntimeContext>} */
    static networkRuntimeContexts = new Map()
    /** @type {Map<string, RuntimeContext>} */
    static webSocketRuntimeContexts = new Map()

    /** @type {Command | null} */
    #currentCommand = null
    /** @type {Command | null} */
    #responseCommand = null

    /**
     * @param {RuntimeNameType} runtimeName
     * @param {IConnectionData} connectionData
     */
    constructor(runtimeName, connectionData) {
        this._isExecuted = false
        this.runtimeName = runtimeName
        this.connectionData = connectionData

        if (this.connectionData.connectionType === ConnectionType.WEB_SOCKET) {
            return
        }
        if (
            this.runtimeName === RuntimeName.Nodejs &&
            this.connectionData.connectionType === ConnectionType.IN_MEMORY
        ) {
            return
        }

        _Transmitter?.setJavonetWorkingDirectory(UtilsConst.getJavonetWorkingDirectory())
        if (UtilsConst.getConfigSource() !== '') {
            _Transmitter?.setConfigSource(UtilsConst.getConfigSource())
        }
        _Transmitter?.activate(UtilsConst.getLicenseKey())
    }

    /**
     * @param {Config} config
     * @returns {RuntimeContext}
     */
    static initializeRuntimeContext(config) {
        const rtmCtx = RuntimeContext.getInstance(config.runtime, config.connectionData)

        if (config.connectionData.connectionType === ConnectionType.IN_MEMORY) {
            const modules = (config.modules || '')
                .split(',')
                .map((m) => m.trim())
                .filter((m) => m !== '')

            // try to get Node's path module; if unavailable, fall back to simple checks
            let pathModule = null
            try {
                // eslint-disable-next-line no-eval
                const _require = typeof require !== 'undefined' ? require : eval('require')
                pathModule = _require('path')
            } catch (e) {
                pathModule = null
            }

            modules.forEach((module) => {
                const fullPath = pathModule
                    ? pathModule.resolve(module)
                    : module
                rtmCtx.loadLibrary(fullPath)
            })
        }

        return rtmCtx
    }

    /**
     * @param {RuntimeNameType} runtimeName
     * @param {IConnectionData} connectionData
     * @returns {RuntimeContext}
     */
    static getInstance(runtimeName, connectionData) {
        if (!isNodejsRuntime() && connectionData.connectionType === ConnectionType.IN_MEMORY) {
            throw new Error('Nodejs Core Error: inMemory is only allowed in Nodejs runtime, not in browser')
        }

        switch (connectionData.connectionType) {
            case ConnectionType.IN_MEMORY:
                const key = String(runtimeName)
                if (RuntimeContext.memoryRuntimeContexts.has(key)) {
                    const runtimeCtx = RuntimeContext.memoryRuntimeContexts.get(key)
                    if (!runtimeCtx) throw new Error('Runtime context not found')
                    runtimeCtx.#currentCommand = null
                    return runtimeCtx
                } else {
                    if (!_Transmitter) {
                        const { Transmitter } = requireDynamic('../core/transmitter/Transmitter.js')
                        _Transmitter = Transmitter
                    }
                    const runtimeCtx = new RuntimeContext(runtimeName, connectionData)
                    RuntimeContext.memoryRuntimeContexts.set(key, runtimeCtx)
                    return runtimeCtx
                }
            case ConnectionType.TCP: {
                const key1 = String(runtimeName) + JSON.stringify(connectionData)
                if (RuntimeContext.networkRuntimeContexts.has(key1)) {
                    const runtimeCtx = RuntimeContext.networkRuntimeContexts.get(key1)
                    if (!runtimeCtx) throw new Error('Runtime context not found')
                    runtimeCtx.#currentCommand = null
                    return runtimeCtx
                } else {
                    if (!_Transmitter) {
                        const { Transmitter } = requireDynamic('../core/transmitter/Transmitter.js')
                        _Transmitter = Transmitter
                    }
                    const runtimeCtx = new RuntimeContext(runtimeName, connectionData)
                    RuntimeContext.networkRuntimeContexts.set(key1, runtimeCtx)
                    return runtimeCtx
                }
            }
            case ConnectionType.WEB_SOCKET: {
                const key2 = String(runtimeName) + JSON.stringify(connectionData)
                if (RuntimeContext.webSocketRuntimeContexts.has(key2)) {
                    const runtimeCtx = RuntimeContext.webSocketRuntimeContexts.get(key2)
                    if (!runtimeCtx) throw new Error('Runtime context not found')
                    runtimeCtx.#currentCommand = null
                    return runtimeCtx
                } else {
                    const runtimeCtx = new RuntimeContext(runtimeName, connectionData)
                    RuntimeContext.webSocketRuntimeContexts.set(key2, runtimeCtx)
                    return runtimeCtx
                }
            }
            default:
                throw new Error('Invalid connection type')
        }
    }

    /**
     * Executes the current command. The initial state of RuntimeContext is non-materialized,
     * wrapping either a single command or a chain of recursively nested commands.
     * Commands become nested through each invocation of methods on RuntimeContext.
     * Each invocation triggers the creation of a new RuntimeContext instance wrapping the current command with a new parent command.
     * The developer can decide at any moment of the materialization for the context, taking full control of the chunks of the expression being transferred and processed on the target runtime.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/foundations/execute-method)
     * @returns {Promise<void>}
     * @method
     */
    async execute() {
        if (!this.#currentCommand) {
            throw new Error('currentCommand is undefined in Runtime Context execute method')
        }
        this.#responseCommand = await Interpreter.execute(this.#currentCommand, this.connectionData)
        this.#currentCommand = null
        if (this.#responseCommand === undefined) {
            throw new Error('responseCommand is undefined in Runtime Context execute method')
        }
        if (this.#responseCommand?.commandType === CommandType.Exception) {
            throw ExceptionThrower.throwException(this.#responseCommand)
        }
    }

    /**
     * Adds a reference to a library. Javonet allows you to reference and use modules or packages written in various languages.
     * This method allows you to use any library from all supported technologies. The necessary libraries need to be referenced.
     * The argument is a relative or full path to the library. If the library has dependencies on other libraries, the latter needs to be added first.
     * After referencing the library, any objects stored in this package can be used. Use static classes, create instances, call methods, use fields and properties, and much more.
     * @param {string} libraryPath - The relative or full path to the library.
     * @returns {Promise<RuntimeContext>} RuntimeContext instance.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/getting-started/adding-references-to-libraries)
     * @method
     */
    async loadLibrary(libraryPath) {
        let localCommand = new Command(this.runtimeName, CommandType.LoadLibrary, [libraryPath])
        this.#currentCommand = this.#buildCommand(localCommand)
        await this.execute()
        return this
    }

    /**
     * Retrieves a reference to a specific type. The type can be a class, interface or enum. The type can be retrieved from any referenced library.
     * @param {string} typeName - The full name of the type.
     * @param {...any} args - The arguments to be passed, if needed
     * @returns {InvocationContext} InvocationContext instance, that wraps the command to get the type.
     * @method
     */
    getType(typeName, ...args) {
        let localCommand = new Command(this.runtimeName, CommandType.GetType, [typeName, ...args])
        this.#currentCommand = null
        return new InvocationContext(this.runtimeName, this.connectionData, this.#buildCommand(localCommand))
    }

    /**
     * Casts the provided value to a specific type. This method is used when invoking methods that require specific types of arguments.
     * The arguments include the target type and the value to be cast. The target type must be retrieved from the called runtime using the getType method.
     * After casting the value, it can be used as an argument when invoking methods.
     * @param {...any} args - The target type and the value to be cast.
     * @returns {InvocationContext} InvocationContext instance that wraps the command to cast the value.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/casting/casting)
     * @method
     */
    cast(...args) {
        let localCommand = new Command(this.runtimeName, CommandType.Cast, args)
        this.#currentCommand = null
        return new InvocationContext(this.runtimeName, this.connectionData, this.#buildCommand(localCommand))
    }

    /**
     * Retrieves a specific item from an enum type. This method is used when working with enums from the called runtime.
     * The arguments include the enum type and the name of the item. The enum type must be retrieved from the called runtime using the getType method.
     * After retrieving the item, it can be used as an argument when invoking methods or for other operations.
     * @param {...any} args - The enum type and the name of the item.
     * @returns {InvocationContext} InvocationContext instance that wraps the command to get the enum item.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/enums/using-enum-type)
     * @method
     */
    getEnumItem(...args) {
        let localCommand = new Command(this.runtimeName, CommandType.GetEnumItem, args)
        this.#currentCommand = null
        return new InvocationContext(this.runtimeName, this.connectionData, this.#buildCommand(localCommand))
    }

    /**
     * Creates a reference type argument that can be passed to a method with a ref parameter modifier. This method is used when working with methods from the called runtime that require arguments to be passed by reference.
     * The arguments include the value and optionally the type of the reference. The type must be retrieved from the called runtime using the getType method.
     * After creating the reference, it can be used as an argument when invoking methods.
     * @param {...any} args - The value and optionally the type of the reference.
     * @returns {InvocationContext} InvocationContext instance that wraps the command to create a reference as ref.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/methods-arguments/passing-arguments-by-reference-with-ref-keyword)
     * @method
     */
    asRef(...args) {
        let localCommand = new Command(this.runtimeName, CommandType.AsRef, args)
        this.#currentCommand = null
        return new InvocationContext(this.runtimeName, this.connectionData, this.#buildCommand(localCommand))
    }

    /**
     * Creates a reference type argument that can be passed to a method with an out parameter modifier. This method is used when working with methods from the called runtime that require arguments to be passed by reference.
     * The arguments include the value and optionally the type of the reference. The type must be retrieved from the called runtime using the getType method.
     * After creating the reference, it can be used as an argument when invoking methods.
     * @param {...any} args - The value and optionally the type of the reference.
     * @returns {InvocationContext} InvocationContext instance that wraps the command to create a reference as out.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/methods-arguments/passing-arguments-by-reference-with-out-keyword |Passing Arguments by Reference with 'out' Keyword Guide)
     * @method
     */
    asOut(...args) {
        let localCommand = new Command(this.runtimeName, CommandType.AsOut, args)
        this.#currentCommand = null
        return new InvocationContext(this.runtimeName, this.connectionData, this.#buildCommand(localCommand))
    }

    /**
     * Retrieves the value of a global field from the target runtime.
     * @param {string} fieldName - The name of the field to get.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to get the global field.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/fields-and-properties/getting-values-for-global-fields)
     * @method
     */
    getGlobalField(fieldName) {
        let localCommand = new Command(this.runtimeName, CommandType.GetGlobalField, [fieldName])
        this.#currentCommand = null
        return new InvocationContext(this.runtimeName, this.connectionData, this.#buildCommand(localCommand))
    }

    /**
     * Invokes a function from the called runtime. This method is used when working with functions from the called runtime.
     * The arguments include the function name and the arguments to be passed to the function.
     * After invoking the function, the result can be used for further operations.
     * @param {string} functionName - The name of the function to invoke.
     * @param {...any} args - The arguments to be passed to the function.
     * @returns {InvocationContext} InvocationContext instance that wraps the command to invoke the function.
     * @see [Invoking Functions Guide](https://www.javonet.com/guides/v2/csharp/functions/invoking-functions)
     * @method
     */
    invokeGlobalFunction(functionName, ...args) {
        let localCommand = new Command(this.runtimeName, CommandType.InvokeGlobalFunction, [
            functionName,
            ...args,
        ])
        this.#currentCommand = null
        return new InvocationContext(this.runtimeName, this.connectionData, this.#buildCommand(localCommand))
    }

    /**
     * @param {Command} command
     * @returns {Command}
     */
    #buildCommand(command) {
        for (let i = 0; i < command.payload.length; i++) {
            command.payload[i] = this.#encapsulatePayloadItem(command.payload[i])
        }
        return command.prependArgToPayload(this.#currentCommand)
    }

    /**
     * @param {unknown} payloadItem
     * @returns {Command}
     */
    #encapsulatePayloadItem(payloadItem) {
        if (payloadItem instanceof Command) {
            for (let i = 0; i < payloadItem.payload.length; i++) {
                payloadItem.payload[i] = this.#encapsulatePayloadItem(payloadItem.payload[i])
            }
            return payloadItem
        } else if (payloadItem instanceof InvocationContext) {
            const command = payloadItem?.getCurrentCommand()
            if (!command) {
                throw new Error('Command not found')
            }
            return command
        } else if (payloadItem instanceof Array) {
            /** @type {Command[]} */
            const copiedArray = payloadItem.map((item) => this.#encapsulatePayloadItem(item))
            return new Command(this.runtimeName, CommandType.Array, copiedArray)
        } else if (typeof payloadItem === 'function') {
            let newArray = new Array(payloadItem.length + 1)
            for (let i = 0; i < newArray.length; i++) {
                newArray[i] = 'object'
            }
            const args = [delegatesCacheInstance.addDelegate(payloadItem), RuntimeName.Nodejs]
            args.push(...newArray)
            return new Command(this.runtimeName, CommandType.PassDelegate, args)
        } else if (TypesHandler.isPrimitiveOrNullOrUndefined(payloadItem)) {
            return new Command(this.runtimeName, CommandType.Value, [payloadItem])
        } else {
            throw Error(
                'Unsupported payload item type: ' +
                    (payloadItem?.constructor?.name || typeof payloadItem) +
                    ' for payload item: ' +
                    payloadItem
            )
        }
    }
}

export { RuntimeContext }
