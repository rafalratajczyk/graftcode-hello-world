// @ts-check

import { RuntimeNameHandler } from '../../../utils/RuntimeNameHandler.js'
import { InMemoryConnectionData } from '../../../utils/connectionData/InMemoryConnectionData.js'
import { WsConnectionData } from '../../../utils/connectionData/WsConnectionData.js'
import { TcpConnectionData } from '../../../utils/nodejs/connectionData/TcpConnectionData.js'

class ConfigResolver {
    /**
     * Parse a runtime string into the runtime enum/name using RuntimeNameHandler.
     * @param {string} runtime
     * @returns {*}
     */
    static tryParseRuntime(runtime) {
        if (!runtime || String(runtime).trim() === '') {
            throw new Error('Runtime string cannot be null or whitespace.')
        }
        const normalized = String(runtime).trim().toLowerCase()
        return RuntimeNameHandler.getRuntime(normalized)
    }

    /**
     * Build appropriate connection data object from a host string.
     * - empty / null => InMemoryConnectionData
     * - "inmemory" or "in-memory" => InMemoryConnectionData
     * - ws:// or wss:// => WsConnectionData(fullAddress)
     * - tcp://... => parsed by parseTcp
     * - host:port or host:port/... => TcpConnectionData(host, port) if valid, otherwise InMemoryConnectionData
     * @param {string} hostValue
     * @returns {InMemoryConnectionData|WsConnectionData|TcpConnectionData}
     */
    static buildConnectionData(hostValue) {
        if (!hostValue || String(hostValue).trim() === '') {
            return new InMemoryConnectionData()
        }

        const hv = String(hostValue).trim()
        const lower = hv.toLowerCase()

        if (lower === 'inmemory' || lower === 'in-memory') {
            return new InMemoryConnectionData()
        }

        if (lower.startsWith('ws://') || lower.startsWith('wss://')) {
            return new WsConnectionData(hv)
        }

        if (lower.startsWith('tcp://')) {
            try {
                // slice off 'tcp://'
                return ConfigResolver.parseTcp(hv.slice(6))
            } catch (e) {
                return new InMemoryConnectionData()
            }
        }

        const colon = hv.indexOf(':')
        if (colon > 0 && colon < hv.length - 1) {
            let portPart = hv.substring(colon + 1)
            const slash = portPart.indexOf('/')
            if (slash >= 0) {
                portPart = portPart.substring(0, slash)
            }
            try {
                const port = parseInt(portPart, 10)
                if (!Number.isFinite(port) || Number.isNaN(port)) {
                    throw new Error('invalid port')
                }
                const hostOnly = hv.substring(0, colon)
                if (String(hostOnly).trim()) {
                    try {
                        return new TcpConnectionData(hostOnly, port)
                    } catch (e) {
                        return new InMemoryConnectionData()
                    }
                }
            } catch (e) {
                // fall through to in-memory
            }
        }

        return new InMemoryConnectionData()
    }

    /**
     * Parse tcp address portion (after tcp://) into TcpConnectionData.
     * Expected formats: host:port or host:port/...
     * Throws Error on invalid format or port.
     * @param {string} address
     * @returns {TcpConnectionData}
     */
    static parseTcp(address) {
        const slash = address.indexOf('/')
        const hostPort = slash >= 0 ? address.substring(0, slash) : address
        const colon = hostPort.lastIndexOf(':')
        if (colon <= 0 || colon >= hostPort.length - 1) {
            throw new Error('Invalid tcp:// format.')
        }
        const host = hostPort.substring(0, colon)
        const portStr = hostPort.substring(colon + 1)
        const port = parseInt(portStr, 10)
        if (!Number.isFinite(port) || Number.isNaN(port)) {
            throw new Error('Invalid port in tcp:// address.')
        }
        return new TcpConnectionData(host, port)
    }
}

export { ConfigResolver }
