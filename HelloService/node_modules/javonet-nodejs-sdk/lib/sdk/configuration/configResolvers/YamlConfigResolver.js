// @ts-check

import yaml from 'js-yaml'
import { Config } from '../Config.js'
import { ConfigsDictionary } from '../ConfigsDictionary.js'
import { ConfigResolver } from './ConfigResolver.js'
import { ActivationHelper } from '../../tools/ActivationHelper.js'

/**
 * @typedef {{ licenseKey?: string, configurations?: Record<string, Record<string, unknown>> }} RootYaml
 */

class YamlConfigResolver extends ConfigResolver {
    /**
     * Parse YAML string and add configurations.
     * @param {any} priority
     * @param {string} yamlString
     */
    static addConfigs(priority, yamlString) {
        if (!yamlString || String(yamlString).trim() === '') {
            throw new Error('YAML string cannot be null or empty.')
        }

        /** @type {unknown} */
        let data
        try {
            data = yaml.load(String(yamlString))
        } catch (ex) {
            throw new SyntaxError(`Failed to parse YAML: ${ex}`)
        }

        if (typeof data !== 'object' || data == null || Array.isArray(data)) {
            throw new SyntaxError('Root YAML node must be a mapping.')
        }

        /** @type {RootYaml} */
        const root = /** @type {RootYaml} */ (data)

        const licenseKey = root.licenseKey
        if (typeof licenseKey === 'string') {
            // fixed: correct property name casing
            ActivationHelper.temporaryLicenseKey = licenseKey.trim()
        }

        const configs = root.configurations
        if (typeof configs !== 'object' || configs == null || Array.isArray(configs)) {
            throw new Error("YAML must contain 'configurations' mapping.")
        }

        for (const [configName, cfg] of Object.entries(configs)) {
            if (typeof configName !== 'string' || configName.trim() === '') {
                console.log('Skipping entry with empty config name.')
                continue
            }
            if (typeof cfg !== 'object' || cfg == null || Array.isArray(cfg)) {
                console.log(`Skipping '${configName}': value is not a mapping.`)
                continue
            }

            try {
                const runtimeValue = YamlConfigResolver._getRequiredString(cfg, 'runtime')
                const runtimeName = ConfigResolver.tryParseRuntime(runtimeValue)

                const host = YamlConfigResolver._getOptionalString(cfg, 'host')
                const connectionData = ConfigResolver.buildConnectionData(host)

                const plugins = YamlConfigResolver._getOptionalString(cfg, 'plugins')
                const modules = YamlConfigResolver._getOptionalString(cfg, 'modules')

                const config = new Config(runtimeName, connectionData, plugins, modules)
                ConfigsDictionary.addConfig(configName, priority, config)
            } catch (ex) {
                console.log(`Failed to add config '${configName}': ${ex}`)
            }
        }
    }

    /**
     * Get required string from mapping, trimmed. Throws if missing/invalid.
     * @param {Record<string, unknown>} mapping
     * @param {string} key
     * @returns {string}
     * @private
     */
    static _getRequiredString(mapping, key) {
        const value = mapping[key]
        if (typeof value !== 'string' || value.trim() === '') {
            throw new Error(`Missing or invalid '${key}' property.`)
        }
        return value.trim()
    }

    /**
     * Get optional string from mapping, or empty string if missing/not a string.
     * @param {Record<string, unknown>} mapping
     * @param {string} key
     * @returns {string}
     * @private
     */
    static _getOptionalString(mapping, key) {
        const value = mapping[key]
        if (typeof value === 'string') {
            return value
        }
        return ''
    }
}

export { YamlConfigResolver }
