// @ts-check

import { Config } from '../Config.js'
import { ConfigsDictionary } from '../ConfigsDictionary.js'
import { ActivationHelper } from '../../tools/ActivationHelper.js'
import { ConfigResolver } from './ConfigResolver.js'

class ConnectionStringConfigResolver extends ConfigResolver {
    /**
     * Parse and add multiple configuration lines from a connection string source.
     * @param {any} priority
     * @param {string} connectionStringSource
     */
    static addConfigs(priority, connectionStringSource) {
        if (!connectionStringSource || String(connectionStringSource).trim() === '') {
            throw new Error('Connection string source cannot be null or empty.')
        }

        const normalized = String(connectionStringSource).replace(/\r\n/g, '\n').replace(/\r/g, '\n')

        const lines = normalized
            .split('\n')
            .map((l) => l.trim())
            .filter((l) => l.length > 0)

        for (const line of lines) {
            if (line.startsWith('#') || line.startsWith('//')) {
                continue
            }
            if (line.toLowerCase().startsWith('licensekey')) {
                ConnectionStringConfigResolver._setLicenseKey(line)
                continue
            }

            try {
                const keyValues = ConnectionStringConfigResolver._parseKeyValues(line)
                const configName = keyValues.name
                const runtimeValue = keyValues.runtime

                if (!configName || String(configName).trim() === '') {
                    throw new Error('Missing or empty config name.')
                }
                if (!runtimeValue || String(runtimeValue).trim() === '') {
                    throw new Error('Missing or empty runtime.')
                }

                const runtimeName = ConfigResolver.tryParseRuntime(runtimeValue)
                const hostValue = keyValues.host
                const connectionData = ConfigResolver.buildConnectionData(hostValue)
                const plugins = keyValues.plugins || ''
                const modules = keyValues.modules || ''

                const config = new Config(runtimeName, connectionData, plugins, modules)
                ConfigsDictionary.addConfig(configName, priority, config)
            } catch (ex) {
                console.log(`Failed to parse config line: '${line}'. Reason: ${ex}`)
                throw ex
            }
        }
    }

    /**
     * Extract and set temporary license key from a line like "licensekey=VALUE;..."
     * @param {string} line
     * @private
     */
    static _setLicenseKey(line) {
        const eq = line.indexOf('=')
        if (eq > 0 && eq < line.length - 1) {
            let valuePortion = line.substring(eq + 1).trim()
            const semicolon = valuePortion.indexOf(';')
            if (semicolon >= 0) {
                valuePortion = valuePortion.substring(0, semicolon).trim()
            }
            const hashIdx = valuePortion.indexOf('#')
            if (hashIdx >= 0) {
                valuePortion = valuePortion.substring(0, hashIdx).trim()
            }
            const slashes = valuePortion.indexOf('//')
            if (slashes >= 0) {
                valuePortion = valuePortion.substring(0, slashes).trim()
            }
            ActivationHelper.setTemporaryLicenseKey(valuePortion)
        }
    }

    /**
     * Parse semicolon-separated key=value tokens into an object.
     * Ignores malformed tokens and logs them.
     * @param {string} line
     * @returns {Record<string, string>}
     * @private
     */
    static _parseKeyValues(line) {
        /** @type {Record<string, string>} */
        const result = {}
        const segments = line
            .split(';')
            .map((s) => s.trim())
            .filter((s) => s.length > 0)

        for (const segment of segments) {
            const eq = segment.indexOf('=')
            if (eq <= 0 || eq === segment.length - 1) {
                console.log(`Ignoring malformed token '${segment}' in line: ${line}`)
                continue
            }
            const key = segment.substring(0, eq).trim().toLowerCase()
            const value = segment.substring(eq + 1).trim()
            if (key) {
                result[key] = value
            }
        }

        return result
    }
}

export { ConnectionStringConfigResolver }
