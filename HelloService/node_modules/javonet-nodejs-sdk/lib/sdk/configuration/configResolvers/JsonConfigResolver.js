// @ts-check

import { Config } from '../Config.js'
import { ConfigsDictionary } from '../ConfigsDictionary.js'
import { ConfigResolver } from './ConfigResolver.js'
import { ActivationHelper } from '../../tools/ActivationHelper.js'

class JsonConfigResolver extends ConfigResolver {
    /**
     * Parse and add configurations from a JSON object.
     * @param {any} priority
     * @param {Record<string, unknown>} jsonObject
     */
    static addConfigs(priority, jsonObject) {
        if (jsonObject == null) {
            throw new Error('json_object cannot be None')
        }
        if (typeof jsonObject !== 'object' || Array.isArray(jsonObject)) {
            throw new Error('Root JSON element must be a dict/object.')
        }

        const licenseKey = /** @type {Record<string, unknown>} */ (jsonObject).licenseKey
        if (typeof licenseKey === 'string') {
            ActivationHelper.setTemporaryLicenseKey(licenseKey.trim())
        }

        const configs = /** @type {Record<string, unknown>} */ (jsonObject).configurations
        if (typeof configs !== 'object' || configs == null || Array.isArray(configs)) {
            throw new Error("JSON must contain 'configurations' object.")
        }

        for (const [configName, cfg] of Object.entries(/** @type {Record<string, unknown>} */ (configs))) {
            try {
                if (typeof cfg !== 'object' || cfg == null || Array.isArray(cfg)) {
                    throw new Error('Configuration value must be an object/dict.')
                }

                const runtimeValue = JsonConfigResolver._getRequiredString(
                    /** @type {Record<string, unknown>} */ (cfg),
                    'runtime'
                )
                const runtimeName = ConfigResolver.tryParseRuntime(runtimeValue)

                const host = JsonConfigResolver._getOptionalString(
                    /** @type {Record<string, unknown>} */ (cfg),
                    'host'
                )
                const connectionData = ConfigResolver.buildConnectionData(host)

                const plugins = JsonConfigResolver._getOptionalString(
                    /** @type {Record<string, unknown>} */ (cfg),
                    'plugins'
                )
                const modules = JsonConfigResolver._getOptionalString(
                    /** @type {Record<string, unknown>} */ (cfg),
                    'modules'
                )

                const config = new Config(runtimeName, connectionData, plugins, modules)
                ConfigsDictionary.addConfig(configName, priority, config)
            } catch (ex) {
                console.log(`Failed to add config '${configName}': ${ex}`)
            }
        }
    }

    /**
     * Get a required string property from an object, trimmed.
     * Throws if missing or empty.
     * @param {Record<string, unknown>} obj
     * @param {string} property
     * @returns {string}
     * @private
     */
    static _getRequiredString(obj, property) {
        const value = obj[property]
        if (typeof value !== 'string' || value.trim() === '') {
            throw new Error(`Missing or invalid '${property}' property.`)
        }
        return value.trim()
    }

    /**
     * Get an optional string property; return empty string when missing or not a string.
     * @param {Record<string, unknown>} obj
     * @param {string} property
     * @returns {string}
     * @private
     */
    static _getOptionalString(obj, property) {
        const value = obj[property]
        if (typeof value === 'string') {
            return value
        }
        return ''
    }
}

export { JsonConfigResolver }
