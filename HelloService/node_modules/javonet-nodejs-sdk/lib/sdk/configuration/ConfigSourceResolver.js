// @ts-check

import { ConfigsDictionary } from './ConfigsDictionary.js'
import { JsonConfigResolver } from './configResolvers/JsonConfigResolver.js'
import { YamlConfigResolver } from './configResolvers/YamlConfigResolver.js'
import { ConnectionStringConfigResolver } from './configResolvers/ConnectionStringConfigResolver.js'
import { getRequire, isNodejsRuntime } from '../../utils/Runtime.js'

/** @type {typeof import('fs') | null} */
let fs = null
/** @type {typeof import('process') | null} */
let process = null

const requireDynamic = getRequire(import.meta.url)
class ConfigSourceResolver {
    /**
     * @param {import('./ConfigPriority.js').ConfigPriority} priority
     * @param {string | any} configSource
     */
    static addConfigs(priority, configSource) {
        console.log(`Adding config from source: ${configSource} with priority '${priority}'`)
        if (configSource && typeof configSource === 'object') {
            JsonConfigResolver.addConfigs(priority, configSource)
        } else {
            const configString = ConfigSourceResolver._getConfigSourceAsString(configSource)
            ConfigSourceResolver._parseConfigsAndAddToCollection(priority, configString)
        }
    }

    /**
     * @param {string} configName
     * @returns {*}
     */
    static getConfig(configName) {
        console.log(`Retrieving config ${configName}`)
        return ConfigsDictionary.getConfig(configName)
    }

    static clearConfigs() {
        ConfigsDictionary.clearConfigs()
    }

    /**
     * @param {string} configSource
     * @returns {string}
     */
    static _getConfigSourceAsString(configSource) {
        if (!configSource || configSource.trim() === '') {
            throw new Error('Config source cannot be null or whitespace.')
        }

        if (isNodejsRuntime()) {
            if (!process) {
                process = requireDynamic('process')
            }
            if (!fs) {
                fs = requireDynamic('fs')
            }

            const envValue = process?.env[configSource]
            if (envValue && envValue.trim() !== '') {
                configSource = envValue
            }
            if (fs?.existsSync(configSource) && fs?.statSync(configSource).isFile()) {
                configSource = fs.readFileSync(configSource, { encoding: 'utf-8' })
            }
        }
        return configSource.trim()
    }

    /**
     * @param {import('./ConfigPriority.js').ConfigPriority} priority
     * @param {string} configString
     * @returns
     */
    static _parseConfigsAndAddToCollection(priority, configString) {
        // JSON
        try {
            const jsonObject = JSON.parse(configString)
            JsonConfigResolver.addConfigs(priority, jsonObject)
            return
        } catch (ex) {
            if (ex instanceof SyntaxError) {
                // not JSON
            } else {
                console.log('Failed to parse config source as JSON: ' + ex)
            }
        }

        // YAML
        try {
            YamlConfigResolver.addConfigs(priority, configString)
            return
        } catch (ex) {
            // @ts-expect-error
            if (ex?.name === 'SyntaxError') {
                // not YAML
            } else {
                console.log('Failed to parse config source as YAML: ' + ex)
            }
        }

        // Connection string
        try {
            ConnectionStringConfigResolver.addConfigs(priority, configString)
            return
        } catch (ex) {
            console.log('Failed to parse config source as connection string: ' + ex)
        }

        throw new Error(
            'Config source is not valid JSON, YAML, or connection string format:\n' + configString
        )
    }
}

export { ConfigSourceResolver }
