//@ts-check
import { delegatesCacheInstance } from '../core/delegatesCache/DelegatesCache.js'
import { Interpreter } from '../core/interpreter/Interpreter.js'
import { Command } from '../utils/Command.js'
import { CommandType } from '../utils/CommandType.js'
import { ExceptionThrower } from '../utils/exception/ExceptionThrower.js'
import { RuntimeName } from '../utils/RuntimeName.js'
import { TypesHandler } from '../utils/TypesHandler.js'
import { v4 as uuidv4 } from 'uuid' // add lightweight uuid generation

/**
 * @typedef {import('../types.d.ts').RuntimeName} RuntimeNameType
 * @typedef {import('../utils/connectionData/IConnectionData.js').IConnectionData} IConnectionData
 */

/**
 * Simple async lock implementation to ensure sequential execution of critical sections.
 */
class AsyncLock {
    constructor() {
        this._tail = Promise.resolve()
    }
    async lock() {
        /**
         * @type {(value?: any) => void}
         */
        let release
        const prev = this._tail
        this._tail = new Promise((res) => (release = res))
        await prev
        return () => release(undefined)
    }
}

/**
 * InvocationContext is a class that represents a context for invoking commands.
 * It implements several interfaces for different types of interactions.
 * This class is used to construct chains of invocations, representing expressions of interaction that have not yet been executed.
 * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/foundations/invocation-context)
 * @class
 */
class InvocationContext {
    /** @type {RuntimeNameType} */
    #runtimeName
    /** @type {IConnectionData} */
    #connectionData
    /** @type {Command | null} */
    #currentCommand = null
    /** @type {Command | null} */
    #responseCommand = null
    /** @type {boolean} */
    #isExecuted = false
    /** @type {string | null} */
    #guid = null
    /** @type {AsyncLock} */
    #materializationLock = new AsyncLock()

    // Static map holding contexts waiting for materialization (guid -> InvocationContext)
    static _invocationContexts = new Map()

    //

    /**
     *
     * @param {RuntimeNameType} runtimeName
     * @param {IConnectionData} connectionData
     * @param {Command} command
     * @param {boolean} isExecuted
     */
    constructor(runtimeName, connectionData, command, isExecuted = false) {
        this.#runtimeName = runtimeName
        this.#connectionData = connectionData
        this.#currentCommand = command
        this.#responseCommand = null
        this.#isExecuted = isExecuted
        this.#guid = uuidv4()
    }

    /**
     * @returns {string} guid of this InvocationContext
     */
    getGuid() {
        // @ts-ignore
        return this.#guid
    }

    /**
     * @param {Command} localCommand
     * @returns {InvocationContext}
     */
    #createInstanceContext(localCommand) {
        return new InvocationContext(
            this.#runtimeName,
            this.#connectionData,
            this.#buildCommand(localCommand)
        )
    }

    /**
     * @returns {Command|null}
     */
    getCurrentCommand() {
        return this.#currentCommand
    }

    //destructor() {
    //    if (this.#currentCommand.commandType === CommandType.Reference) {
    //        this.#currentCommand = new Command(
    //            this.#runtimeName,
    //            CommandType.DestructReference,
    //            this.#currentCommand.payload
    //        );
    //        this.execute();
    //    }
    //}
    /**
     * Async iterator for InvocationContext arrays
     * Use: for await (const item of invocationContext) { ... }
     * @returns {AsyncGenerator<InvocationContext, void, unknown>}
     */
    async *[Symbol.asyncIterator]() {
        if (this.#currentCommand?.commandType !== CommandType.Reference) {
            throw new Error('Object is not iterable')
        }

        const sizeCtx = await this.getSize().execute()
        const arraySize = Number(sizeCtx.getValue())

        for (let position = 0; position < arraySize; position++) {
            yield this.getIndex(position)
        }
    }

    /**
     * Executes the current command.
     * Returns the InvocationContext after executing the command.
     * @returns {Promise<InvocationContext>}
     * @method
     */
    async execute() {
        if (this.#currentCommand === null) {
            throw new Error('currentCommand is undefined in Invocation Context execute method')
        }

        const entries = Array.from(InvocationContext._invocationContexts.entries())
        entries.sort((a, b) => String(a[0]).localeCompare(String(b[0])))
        const releases = []
        for (const [, ic] of entries) {
            // eslint-disable-next-line no-await-in-loop
            const release = await ic.#materializationLock.lock()
            releases.push(release)
        }

        try {
            // Execute command on interpreter
            this.#responseCommand = await Interpreter.execute(
                this.#currentCommand,
                this.#connectionData
            )


            if (!this.#responseCommand) {
                throw new Error('responseCommand is undefined in Invocation Context execute method')
            }
            if (this.#responseCommand.commandType === CommandType.Exception) {
                throw ExceptionThrower.throwException(this.#responseCommand)
            }

            // Process ValueForUpdate commands in response payload
            this.#responseCommand = this.#processUpdateInvocationContextCommands(this.#responseCommand)

            if (this.#responseCommand.commandType === CommandType.CreateClassInstance) {
                this.#currentCommand = this.#responseCommand
                this.#isExecuted = true
                return this
            }
            return new InvocationContext(this.#runtimeName, this.#connectionData, this.#responseCommand, true)
        } finally {
            // Release all locks in reverse order
            for (let i = releases.length - 1; i >= 0; i--) {
                try { releases[i]() } catch { /* ignore */ }
            }
        }
    }

    /**
     * Process UpdateInvocationContext commands in the provided responseCommand payload.
     * For each ValueForUpdate command, set the referenced InvocationContext's currentCommand to a Reference command,
     * remove that InvocationContext from the static map and remove ValueForUpdate items from response payload.
     * @param {Command} responseCommand
     * @returns {Command}
     */
    #processUpdateInvocationContextCommands(responseCommand) {
        if (!responseCommand?.payload || responseCommand.payload.length === 0) {
            return responseCommand
        }

        /** @type {Command[]} */
        const commandsToUpdate = []
        for (const item of responseCommand.payload) {
            if (item instanceof Command && item.commandType === CommandType.ValueForUpdate) {
                commandsToUpdate.push(item)
            }
        }
        if (commandsToUpdate.length === 0) {
            return responseCommand
        }

        // create a copy of the payload to modify
        const updatedPayload = Array.from(responseCommand.payload)

        // update each InvocationContext referenced in ValueForUpdate commands
        for (const cmd of commandsToUpdate) {
            const cmdPayload = cmd.payload
            if (cmdPayload && cmdPayload.length >= 2) {
                const contextGuid = String(cmdPayload[0])
                const instanceGuid = String(cmdPayload[1])
                const invCtx = InvocationContext._invocationContexts.get(contextGuid)
                if (invCtx) {
                    invCtx.#currentCommand = new Command(invCtx.#runtimeName, CommandType.Reference, [instanceGuid])
                    InvocationContext._invocationContexts.delete(contextGuid)
                }
            }
            // remove ValueForUpdate command from payload
            const idx = updatedPayload.indexOf(cmd)
            if (idx >= 0) updatedPayload.splice(idx, 1)
        }

        return new Command(responseCommand.runtimeName, responseCommand.commandType, updatedPayload)
    }

    /**
     * Invokes a static method on the target runtime.
     * @param {string} methodName - The name of the method to invoke.
     * @param {...any} args - Method arguments.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to invoke the static method.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/calling-methods/invoking-static-method)
     * @method
     */
    invokeStaticMethod(methodName, ...args) {
        let localCommand = new Command(this.#runtimeName, CommandType.InvokeStaticMethod, [
            methodName,
            ...args,
        ])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Retrieves the value of a static field from the target runtime.
     * @param {string} fieldName - The name of the field to get.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to get the static field.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/fields-and-properties/getting-and-setting-values-for-static-fields-and-properties)
     * @method
     */
    getStaticField(fieldName) {
        let localCommand = new Command(this.#runtimeName, CommandType.GetStaticField, [fieldName])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Sets the value of a static field in the target runtime.
     * @param {string} fieldName - The name of the field to set.
     * @param {any} value - The new value of the field.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to set the static field.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/fields-and-properties/getting-and-setting-values-for-static-fields-and-properties)
     * @method
     */
    setStaticField(fieldName, value) {
        let localCommand = new Command(this.#runtimeName, CommandType.SetStaticField, [fieldName, value])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Creates a new instance of a class in the target runtime.
     * Adds the newly created context to the static invocation contexts map and
     * includes the context GUID as the first argument of CreateClassInstance command payload.
     * @param {...any} args - The arguments to pass to the class constructor
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to create the instance.
     * @method
     */
    createInstance(...args) {
        const localCommand = new Command(this.#runtimeName, CommandType.CreateClassInstance, [...args])
        const createInstanceInvCtx = this.#createInstanceContext(localCommand)
        return createInstanceInvCtx.#registerForUpdate()
    }

    /**
     * Registers the current InvocationContext for updates.
     * @returns {InvocationContext}
     */
    #registerForUpdate() {
        this.#currentCommand = this.#buildCommand(new Command(this.#runtimeName, CommandType.RegisterForUpdate, [this.getGuid()]))
        InvocationContext._invocationContexts.set(this.getGuid(), this)
        return this
    }

    /**
     * Retrieves the value of an instance field from the target runtime.
     * @param {string} fieldName - The name of the field to get.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to get the instance field.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/fields-and-properties/getting-and-setting-values-for-instance-fields-and-properties)
     * @method
     */
    getInstanceField(fieldName) {
        let localCommand = new Command(this.#runtimeName, CommandType.GetInstanceField, [fieldName])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Sets the value of an instance field in the target runtime.
     * @param {string} fieldName - The name of the field to set.
     * @param {any} value - The new value of the field.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to set the instance field.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/fields-and-properties/getting-and-setting-values-for-instance-fields-and-properties)
     * @method
     */
    setInstanceField(fieldName, value) {
        let localCommand = new Command(this.#runtimeName, CommandType.SetInstanceField, [fieldName, value])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Invokes an instance method on the target runtime.
     * @param {string} methodName - The name of the method to invoke.
     * @param {...any} args - Method arguments.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to invoke the instance method.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/calling-methods/invoking-instance-method)
     * @method
     */
    invokeInstanceMethod(methodName, ...args) {
        let localCommand = new Command(this.#runtimeName, CommandType.InvokeInstanceMethod, [
            methodName,
            ...args,
        ])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Retrieves the value at a specific index in an array from the target runtime.
     * @param {...any} indexes - the arguments to pass to the array getter. The first argument should be the index.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to get the index.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/arrays-and-collections/one-dimensional-arrays)
     * @method
     */
    getIndex(...indexes) {
        let localCommand = new Command(this.#runtimeName, CommandType.ArrayGetItem, indexes)
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Sets the value at a specific index in an array in the target runtime.
     * @param {number[]} indexes - The index to set the value at.
     * @param {any} value - The value to set at the index.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to set the index.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/arrays-and-collections/one-dimensional-arrays)
     * @method
     */
    setIndex(indexes, value) {
        let localCommand = new Command(this.#runtimeName, CommandType.ArraySetItem, [indexes, value])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Retrieves the size of an array from the target runtime.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to get the size.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/arrays-and-collections/one-dimensional-arrays)
     * @method
     */
    getSize() {
        let localCommand = new Command(this.#runtimeName, CommandType.ArrayGetSize, [])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Retrieves the rank of an array from the target runtime.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to get the rank.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/arrays-and-collections/one-dimensional-arrays)
     * @method
     */
    getRank() {
        let localCommand = new Command(this.#runtimeName, CommandType.ArrayGetRank, [])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Invokes a generic static method on the target runtime.
     * @param {string} methodName - The name of the method to invoke.
     * @param {...any} args - Method arguments.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to invoke the generic static method.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/generics/calling-generic-static-method)
     * @method
     */
    invokeGenericStaticMethod(methodName, ...args) {
        let localCommand = new Command(this.#runtimeName, CommandType.InvokeGenericStaticMethod, [
            methodName,
            ...args,
        ])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Invokes a generic method on the target runtime.
     * @param {string} methodName - The name of the method to invoke.
     * @param {...any} args - Method arguments.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to invoke the generic method.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/generics/calling-generic-instance-method)
     * @method
     */
    invokeGenericMethod(methodName, ...args) {
        let localCommand = new Command(this.#runtimeName, CommandType.InvokeGenericMethod, [
            methodName,
            ...args,
        ])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Retrieves the name of an enum from the target runtime.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to get the enum name.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/enums/using-enum-type)
     * @method
     */
    getEnumName() {
        let localCommand = new Command(this.#runtimeName, CommandType.GetEnumName, [])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Retrieves the value of an enum from the target runtime.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to get the enum value.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/enums/using-enum-type)
     * @method
     */
    getEnumValue() {
        let localCommand = new Command(this.#runtimeName, CommandType.GetEnumValue, [])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Retrieves the value of a reference from the target runtime.
     * @returns {InvocationContext} A new InvocationContext instance that wraps the command to get the ref value.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/methods-arguments/passing-arguments-by-reference-with-ref-keyword)
     * @method
     */
    getRefValue() {
        let localCommand = new Command(this.#runtimeName, CommandType.GetRefValue, [])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Creates a null object of a specific type on the target runtime.
     *
     * @returns {InvocationContext} An InvocationContext instance with the command to create a null object.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/null-handling/create-null-object)
     * @method
     */
    createNull() {
        let localCommand = new Command(this.#runtimeName, CommandType.CreateNull, [])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Creates a null object of a specific type on the target runtime.
     * @param {string} methodName - The name of the method to invoke.
     * @param {...any} args - Method arguments.
     * @returns {InvocationContext} An InvocationContext instance with the command to create a null object.
     * TODO: connect documentation page url
     * @see [Javonet Guides](https://www.javonet.com/guides/)
     * @method
     */
    getStaticMethodAsDelegate(methodName, ...args) {
        const localCommand = new Command(this.#runtimeName, CommandType.GetStaticMethodAsDelegate, [
            methodName,
            ...args,
        ])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Creates a null object of a specific type on the target runtime.
     * @param {string} methodName - The name of the method to invoke.
     * @param {...any} args - Method arguments.
     * @returns {InvocationContext} An InvocationContext instance with the command to create a null object.
     * TODO: connect documentation page url
     * @see [Javonet Guides](https://www.javonet.com/guides/)
     * @method
     */
    getInstanceMethodAsDelegate(methodName, ...args) {
        const localCommand = new Command(this.#runtimeName, CommandType.GetInstanceMethodAsDelegate, [
            methodName,
            ...args,
        ])
        return this.#createInstanceContext(localCommand)
    }

    /**
     * Retrieves the type of the object from the target runtime.
     * @returns {Promise<string>} The type of the object.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/type-handling/getting-object-type)
     * @method
     */
    async getResultType() {
        const localCommand = new Command(this.#runtimeName, CommandType.GetResultType, [])
        const invocationContext = new InvocationContext(
            this.#runtimeName,
            this.#connectionData,
            this.#buildCommand(localCommand)
        )
        const execCtx = await invocationContext.execute()
        return String(execCtx.getValue())
    }

    /**
     * Retrieves the name of the runtime where the command is executed.
     * @returns {number} The name of the runtime.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/runtime-name)
     * @method
     */
    getRuntimeName() {
        return this.#runtimeName
    }

    /**
     * Retrieves an array from the target runtime.
     * @async
     * @returns {Promise<any[]>}
     * @method
     */
    async retrieveArray() {
        const localCommand = new Command(this.#runtimeName, CommandType.RetrieveArray, [])
        const localInvCtx = new InvocationContext(
            this.#runtimeName,
            this.#connectionData,
            this.#buildCommand(localCommand)
        )

        await localInvCtx.execute()

        const respCommand = localInvCtx.#responseCommand
        if (!respCommand || !respCommand.payload || respCommand.payload.length === 0) {
            return []
        }

        // Return a shallow copy of the payload, mirroring the C# logic of copying to an object[]
        return respCommand.payload || []
    }

    /**
     * Returns the primitive value from the target runtime. This could be any primitive type in JavaScript,
     * such as int, boolean, byte, char, long, double, float, etc.
     * @returns {unknown} The value of the current command.
     * @see [Javonet Guides](https://www.javonet.com/guides/v2/javascript/foundations/execute-method)
     * @method
     */
    getValue() {
        return this.#currentCommand?.payload[0]
    }

    /**
     * @param {Command} command
     * @returns {Command}
     */
    #buildCommand(command) {
        for (let i = 0; i < command.payload.length; i++) {
            command.payload[i] = this.#encapsulatePayloadItem(command.payload[i])
        }
        return command.prependArgToPayload(this.#currentCommand)
    }

    /**
     * @param {unknown} payloadItem
     * @returns {Command|null}
     */
    #encapsulatePayloadItem(payloadItem) {
        // eslint-disable-next-line valid-typeof
        if (payloadItem instanceof Command) {
            for (let i = 0; i < payloadItem.payload.length; i++) {
                payloadItem.payload[i] = this.#encapsulatePayloadItem(payloadItem.payload[i])
            }
            return payloadItem
            // eslint-disable-next-line valid-typeof
        } else if (payloadItem instanceof InvocationContext) {
            return payloadItem.getCurrentCommand()
        } else if (payloadItem instanceof Array) {
            const copiedArray = payloadItem.map((item) => this.#encapsulatePayloadItem(item))
            return new Command(this.#runtimeName, CommandType.Array, copiedArray)
        } else if (typeof payloadItem === 'function') {
            let newArray = new Array(payloadItem.length + 1)
            for (let i = 0; i < newArray.length; i++) {
                newArray[i] = typeof Object
            }
            const args = [delegatesCacheInstance.addDelegate(payloadItem), RuntimeName.Nodejs]
            args.push(...newArray)
            return new Command(this.#runtimeName, CommandType.PassDelegate, args)
        } else if (TypesHandler.isPrimitiveOrNullOrUndefined(payloadItem)) {
            return new Command(this.#runtimeName, CommandType.Value, [payloadItem])
        } else {
            throw Error(
                'Unsupported payload item type: ' +
                    (payloadItem?.constructor?.name || typeof payloadItem) +
                    ' for payload item: ' +
                    payloadItem
            )
        }
    }
}

export { InvocationContext }
