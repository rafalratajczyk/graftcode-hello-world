// @ts-check
import { IConnectionData } from '../../connectionData/IConnectionData.js'
import { ConnectionType } from '../../ConnectionType.js'
import { getRequire, isNodejsRuntime } from '../../Runtime.js'

const requireDynamic = getRequire(import.meta.url)

/**
 * @typedef {import('../../ConnectionType.js').ConnectionType} ConnectionType
 * @extends IConnectionData
 */
export class TcpConnectionData extends IConnectionData {
    /** @type {string} */
    ipAddress = ''
    /** @type {number} */
    _port = 0
    /** @type {string} */
    _hostname = ''
    /** @type {ConnectionType} */
    _connectionType = ConnectionType.TCP

    /**
     * @param {string} hostname
     * @param {number} port
     */
    constructor(hostname, port) {
        super()
        this._port = port
        this._hostname = hostname
        this._connectionType = ConnectionType.TCP
        if (hostname === 'localhost') {
            this.ipAddress = '127.0.0.1'
        } else {
            this.ipAddress = this.resolveIpAddress(hostname)
        }
    }

    /**
     * @returns {ConnectionType}
     */
    get connectionType() {
        return this._connectionType
    }

    get hostname() {
        return this._hostname
    }

    /**
     * @param {TcpConnectionData} other
     * @returns {boolean}
     */
    equals(other) {
        if (other instanceof TcpConnectionData) {
            return this.ipAddress === other.ipAddress && this._port === other._port
        }
        return false
    }

    /**
     * @param {string} hostname
     * @returns {string}
     */
    resolveIpAddress(hostname) {
        try {
            if (isNodejsRuntime()) {
                // Check if the input is an IP address
                const ipPattern = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/
                if (ipPattern.test(hostname)) {
                    // If it's an IP address, return it directly
                    return hostname
                } else {
                    const dns = requireDynamic('dns')

                    // If it's not an IP address, try to resolve it as a hostname
                    return dns.resolve4(
                        hostname,
                        (/** @type {Error | null} */ err, /** @type {string[]} */ addresses) => {
                            if (err) {
                                console.error(err)
                                return ''
                            }
                            return addresses[0]
                        }
                    )
                }
            }
            return ''
        } catch (error) {
            const err = /** @type {{code?: string}} */ (error)
            if (err.code === 'MODULE_NOT_FOUND') {
                throw new Error('dns module not found. Please install it using npm install dns')
            }
            throw error
        }
    }

    /**
     * Serializes the connection data.
     * @returns {number[]} An array of connection data values.
     */
    serializeConnectionData() {
        let result = [this.connectionType]
        result = result.concat(this.#getAddressBytes())
        result = result.concat(this.#getPortBytes())
        return result
    }

    /**
     * @returns {number[]} An array of address bytes.
     */
    #getAddressBytes() {
        return this.ipAddress.split('.').map(Number)
    }

    /**
     * @returns {number[]} An array of port bytes.
     */
    #getPortBytes() {
        return [this._port & 0xff, this._port >> 8]
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.ipAddress}:${this._port}`
    }
}
