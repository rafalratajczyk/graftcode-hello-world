import { CommandType } from '../CommandType.js'
import { Command } from '../Command.js'
import { RuntimeName } from '../RuntimeName.js'
import { ExceptionType } from '../ExceptionType.js'

class ExceptionSerializer {
    static serializeException(exception, command) {
        let exceptionCommand = new Command(RuntimeName.Nodejs, CommandType.Exception, [])

        let stackClasses = []
        let stackMethods = []
        let stackLines = []
        let stackFiles = []

        try {
            this.serializeStackTrace(exception, stackClasses, stackMethods, stackLines, stackFiles)

            exceptionCommand = exceptionCommand.addArgToPayload(this.getExceptionCode(exception))
            exceptionCommand = exceptionCommand.addArgToPayload(
                command ? command.toString() : 'Command is null'
            )
            exceptionCommand = exceptionCommand.addArgToPayload(exception.name)
            exceptionCommand = exceptionCommand.addArgToPayload(exception.message)
            exceptionCommand = exceptionCommand.addArgToPayload(stackClasses.join('|'))
            exceptionCommand = exceptionCommand.addArgToPayload(stackMethods.join('|'))
            exceptionCommand = exceptionCommand.addArgToPayload(stackLines.join('|'))
            exceptionCommand = exceptionCommand.addArgToPayload(stackFiles.join('|'))
        } catch (e) {
            exceptionCommand = new Command(RuntimeName.Nodejs, CommandType.Exception, [])
            exceptionCommand = exceptionCommand.addArgToPayload(this.getExceptionCode(e))
            exceptionCommand = exceptionCommand.addArgToPayload(
                command ? command.toString() : 'Command is null'
            )
            exceptionCommand = exceptionCommand.addArgToPayload('Node.js Exception Serialization Error')
            exceptionCommand = exceptionCommand.addArgToPayload(e.message)
            exceptionCommand = exceptionCommand.addArgToPayload('ExceptionSerializer')
            exceptionCommand = exceptionCommand.addArgToPayload('serializeException')
            exceptionCommand = exceptionCommand.addArgToPayload('unknown')
            exceptionCommand = exceptionCommand.addArgToPayload('ExceptionSerializer.js')
        }

        return exceptionCommand
    }

    static getExceptionCode(exception) {
        switch (exception.name) {
            case 'Error':
                return ExceptionType.EXCEPTION
            case 'TypeError':
                return ExceptionType.ILLEGAL_ARGUMENT_EXCEPTION
            case 'RangeError':
                return ExceptionType.INDEX_OUT_OF_BOUNDS_EXCEPTION
            default:
                return ExceptionType.EXCEPTION
        }
    }

    static serializeStackTrace(exception, stackClasses, stackMethods, stackLines, stackFiles) {
        if (!exception || typeof exception.stack !== 'string') {
            return
        }
        const stackTrace = exception.stack.split('\n').slice(1)

        for (const line of stackTrace) {
            const trimmedLine = line.trim()
            if (trimmedLine.includes('Javonet.Node.js')) {
                continue
            }

            // Pattern for: at Class.method (file:line:column) or at functionName (file:line:column)
            let parts = trimmedLine.match(/at\s+(.*?)\s+\((.*?):(\d+):\d+\)/)
            if (parts) {
                const classAndMethod = parts[1].split('.')
                if (classAndMethod.length > 1) {
                    stackClasses.push(classAndMethod[0])
                    stackMethods.push(classAndMethod.slice(1).join('.'))
                } else {
                    stackClasses.push('unknown')
                    stackMethods.push(parts[1])
                }
                stackFiles.push(parts[2])
                stackLines.push(parts[3])
                continue
            }

            // Pattern for: at file:line:column (often for anonymous functions or top-level scripts)
            parts = trimmedLine.match(/at\s+(.*?):(\d+):\d+/)
            if (parts) {
                stackClasses.push('unknown')
                stackMethods.push('unknown')
                stackFiles.push(parts[1])
                stackLines.push(parts[2])
            }
        }
    }
}

export { ExceptionSerializer }
