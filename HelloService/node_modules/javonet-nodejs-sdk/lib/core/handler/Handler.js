//@ts-check

import { CommandType } from '../../utils/CommandType.js'
import { Command } from '../../utils/Command.js'
import { TypesHandler } from '../../utils/TypesHandler.js'
import { ExceptionSerializer } from '../../utils/exception/ExceptionSerializer.js'
import { AbstractHandler } from './AbstractHandler.js'

import { ReferencesCache } from '../referenceCache/ReferencesCache.js'
import { ValueHandler } from './ValueHandler.js'
import { LoadLibraryHandler } from './LoadLibraryHandler.js'
import { InvokeStaticMethodHandler } from './InvokeStaticMethodHandler.js'
import { GetStaticFieldHandler } from './GetStaticFieldHandler.js'
import { SetStaticFieldHandler } from './SetStaticFieldHandler.js'
import { CreateClassInstanceHandler } from './CreateClassInstanceHandler.js'
import { GetTypeHandler } from './GetTypeHandler.js'
import { ResolveReferenceHandler } from './ResolveReferenceHandler.js'
import { GetModuleHandler } from './GetModuleHandler.js'
import { InvokeInstanceMethodHandler } from './InvokeInstanceMethodHandler.js'
import { ExceptionHandler } from './ExceptionHandler.js'
import { HeartBeatHandler } from './HeartBeatHandler.js'
import { CastingHandler } from './CastingHandler.js'
import { GetInstanceFieldHandler } from './GetInstanceFieldHandler.js'
import { OptimizeHandler } from './OptimizeHandler.js'
import { GenerateLibHandler } from './GenerateLibHandler.js'
import { InvokeGlobalFunctionHandler } from './InvokeGlobalFunctionHandler.js'
import { DestructReferenceHandler } from './DestructReferenceHandler.js'
import { ArrayReferenceHandler } from './ArrayReferenceHandler.js'
import { ArrayGetItemHandler } from './ArrayGetItemHandler.js'
import { ArrayGetSizeHandler } from './ArrayGetSizeHandler.js'
import { ArrayGetRankHandler } from './ArrayGetRankHandler.js'
import { ArraySetItemHandler } from './ArraySetItemHandler.js'
import { ArrayHandler } from './ArrayHandler.js'
import { RetrieveArrayHandler } from './RetrieveArrayHandler.js'
import { SetInstanceFieldHandler } from './SetInstanceFieldHandler.js'
import { InvokeGenericStaticMethodHandler } from './InvokeGenericStaticMethodHandler.js'
import { InvokeGenericMethodHandler } from './InvokeGenericMethodHandler.js'
import { GetEnumItemHandler } from './GetEnumItemHandler.js'
import { GetEnumNameHandler } from './GetEnumNameHandler.js'
import { GetEnumValueHandler } from './GetEnumValueHandler.js'
import { AsRefHandler } from './AsRefHandler.js'
import { AsOutHandler } from './AsOutHandler.js'
import { GetRefValueHandler } from './GetRefValueHandler.js'
import { EnableNamespaceHandler } from './EnableNamespaceHandler.js'
import { EnableTypeHandler } from './EnableTypeHandler.js'
import { CreateNullHandler } from './CreateNullHandler.js'
import { GetStaticMethodAsDelegateHandler } from './GetStaticMethodAsDelegateHandler.js'
import { GetInstanceMethodAsDelegateHandler } from './GetInstanceMethodAsDelegateHandler.js'
import { PassDelegateHandler } from './PassDelegateHandler.js'
import { InvokeDelegateHandler } from './InvokeDelegateHandler.js'
import { ConvertTypeHandler } from './ConvertTypeHandler.js'
import { AddEventListenerHandler } from './AddEventListenerHandler.js'
import { PluginWrapperHandler } from './PluginWrapperHandler.js'
import { GetAsyncOperationResultHandler } from './GetAsyncOperationResultHandler.js'
import { AsKwargsHandler } from './AsKwargsHandler.js'
import { GetResultTypeHandler } from './GetResultTypeHandler.js'
import { GetGlobalFieldHandler } from './GetGlobalFieldHandler.js'
import { RegisterForUpdateHandler } from './RegisterForUpdateHandler.js'
import { ValueForUpdateHandler } from './ValueForUpdateHandler.js'

/**
 * @typedef {import('../../types.d.ts').RuntimeName} RuntimeName
 */

/**
 * @type {Record<number, AbstractHandler>}
 */
const handlers = {
    [CommandType.Value]: new ValueHandler(),
    [CommandType.LoadLibrary]: new LoadLibraryHandler(),
    [CommandType.InvokeStaticMethod]: new InvokeStaticMethodHandler(),
    [CommandType.GetStaticField]: new GetStaticFieldHandler(),
    [CommandType.SetStaticField]: new SetStaticFieldHandler(),
    [CommandType.CreateClassInstance]: new CreateClassInstanceHandler(),
    [CommandType.GetType]: new GetTypeHandler(),
    [CommandType.Reference]: new ResolveReferenceHandler(),
    [CommandType.GetModule]: new GetModuleHandler(),
    [CommandType.InvokeInstanceMethod]: new InvokeInstanceMethodHandler(),
    [CommandType.Exception]: new ExceptionHandler(),
    [CommandType.HeartBeat]: new HeartBeatHandler(),
    [CommandType.Cast]: new CastingHandler(),
    [CommandType.GetInstanceField]: new GetInstanceFieldHandler(),
    [CommandType.Optimize]: new OptimizeHandler(),
    [CommandType.GenerateLib]: new GenerateLibHandler(),
    [CommandType.InvokeGlobalFunction]: new InvokeGlobalFunctionHandler(),
    [CommandType.DestructReference]: new DestructReferenceHandler(),
    [CommandType.ArrayReference]: new ArrayReferenceHandler(),
    [CommandType.ArrayGetItem]: new ArrayGetItemHandler(),
    [CommandType.ArrayGetSize]: new ArrayGetSizeHandler(),
    [CommandType.ArrayGetRank]: new ArrayGetRankHandler(),
    [CommandType.ArraySetItem]: new ArraySetItemHandler(),
    [CommandType.Array]: new ArrayHandler(),
    [CommandType.RetrieveArray]: new RetrieveArrayHandler(),
    [CommandType.SetInstanceField]: new SetInstanceFieldHandler(),
    [CommandType.InvokeGenericStaticMethod]: new InvokeGenericStaticMethodHandler(),
    [CommandType.InvokeGenericMethod]: new InvokeGenericMethodHandler(),
    [CommandType.GetEnumItem]: new GetEnumItemHandler(),
    [CommandType.GetEnumName]: new GetEnumNameHandler(),
    [CommandType.GetEnumValue]: new GetEnumValueHandler(),
    [CommandType.AsRef]: new AsRefHandler(),
    [CommandType.AsOut]: new AsOutHandler(),
    [CommandType.GetRefValue]: new GetRefValueHandler(),
    [CommandType.EnableNamespace]: new EnableNamespaceHandler(),
    [CommandType.EnableType]: new EnableTypeHandler(),
    [CommandType.CreateNull]: new CreateNullHandler(),
    [CommandType.GetStaticMethodAsDelegate]: new GetStaticMethodAsDelegateHandler(),
    [CommandType.GetInstanceMethodAsDelegate]: new GetInstanceMethodAsDelegateHandler(),
    [CommandType.PassDelegate]: new PassDelegateHandler(),
    [CommandType.InvokeDelegate]: new InvokeDelegateHandler(),
    [CommandType.ConvertType]: new ConvertTypeHandler(),
    [CommandType.AddEventListener]: new AddEventListenerHandler(),
    [CommandType.PluginWrapper]: new PluginWrapperHandler(),
    [CommandType.GetAsyncOperationResult]: new GetAsyncOperationResultHandler(),
    [CommandType.AsKwargs]: new AsKwargsHandler(),
    [CommandType.GetResultType]: new GetResultTypeHandler(),
    [CommandType.GetGlobalField]: new GetGlobalFieldHandler(),
    [CommandType.RegisterForUpdate]: new RegisterForUpdateHandler(),
    [CommandType.ValueForUpdate]: new ValueForUpdateHandler(),
}

class Handler {
    static _initialized = false

    /**
     * Initializes the handlers map. This is called lazily on first use.
     */
    static _initialize() {
        if (Handler._initialized) {
            return
        }

        // dynamically create pass delegate handler
        handlers[CommandType.PassDelegate] = new PassDelegateHandler()

        Object.keys(handlers).forEach((commandTypeHandler) => {
            // @ts-expect-error
            handlers[commandTypeHandler].handlers = handlers
        })

        Handler._initialized = true
    }

    /**
     * @param {Command} command
     * @returns {Promise<Command> | Command}
     */
    static handleCommand(command) {
        Handler._initialize()
        
        try {
            if (command.commandType === CommandType.RetrieveArray) {
                /** @type {any} */
                const responseArray = handlers[CommandType.Reference].handleCommand(command.payload[0])
                return Command.createArrayResponse(responseArray, command.runtimeName)
            }

            /** @type {any} */
            const response = handlers[command.commandType].handleCommand(command)
            return Handler.parseCommand(response, command.runtimeName)
        } catch (e) {
            return Handler.resolveException(e, command)
        }
    }

    /**
     * Prefer innerException (or cause) when available.
     * @param {any} error
     * @param {Command} command
     * @returns {Command}
     */
    static resolveException(error, command) {
        const inner = error?.cause
        return ExceptionSerializer.serializeException(inner ?? error, command)
    }

    /**
     * @param {any} response
     * @param {RuntimeName} runtimeName
     * @returns {Promise<Command> | Command}
     */
    static parseCommand(response, runtimeName) {
        if (response instanceof Promise) {
            return response.then((resolvedResponse) => {
                return Handler.parseCommand(resolvedResponse, runtimeName)
            })
        }

        let responseCommand
        if (TypesHandler.isPrimitiveOrNullOrUndefined(response)) {
            responseCommand = Command.createResponse(response, runtimeName)
        } else {
            const refCache = ReferencesCache.getInstance()
            const uuid = refCache.cacheReference(response)
            responseCommand = Command.createReference(uuid, runtimeName)
        }

        const invocationContexts = RegisterForUpdateHandler._invocationContexts.Value
        if (invocationContexts && invocationContexts.size > 0) {
            const refCache = ReferencesCache.getInstance()
            for (const [contextKey, instance] of invocationContexts.entries()) {
                const instanceGuid = refCache.cacheReference(instance)

                const updateContextCommand = new Command(
                    runtimeName,
                    CommandType.ValueForUpdate,
                    [contextKey.toString(),
                    instanceGuid]
                )

                if (typeof responseCommand.addArgToPayload === 'function') {
                    responseCommand = responseCommand.addArgToPayload(updateContextCommand)
                } else {
                    responseCommand.payload = responseCommand.payload || []
                    responseCommand.payload.push(updateContextCommand)
                }
            }

            // Clear all entries after processing this request
            invocationContexts.clear()
        }

        return responseCommand
    }
}

export { Handler, handlers }
