// @ts-check
import { AbstractHandler } from './AbstractHandler.js'
import { LoadLibraryHandler } from './LoadLibraryHandler.js'
import { NamespaceCache } from '../namespaceCache/NamespaceCache.js'
import { TypeCache } from '../typeCache/TypeCache.js'
import { getRequire } from '../../utils/Runtime.js'

/**
 * @typedef {import('../../utils/Command.js').Command} Command
 */
class GetTypeHandler extends AbstractHandler {
    constructor() {
        super()
        /** @type {number} */
        this.requiredParametersCount = 1
        /** @type {NamespaceCache} */
        this.namespaceCache = new NamespaceCache()
        /** @type {TypeCache} */
        this.typeCache = new TypeCache()
        /** @type {LoadLibraryHandler} */
        this.loadLibaryHandler = new LoadLibraryHandler()
    }

    /**
     *
     * @param {Command} command
     * @returns
     */
    process(command) {
        try {
            if (command.payload.length < this.requiredParametersCount) {
                throw new Error('Get Type parameters mismatch')
            }
            const { payload } = command
            let typeName = payload[0]
            typeName = typeName.replace('.js', '')
            const typeToReturn = /** @type {any} */ (global)[typeName]
            if (typeToReturn === undefined) {
                let message = `Type ${typeName} not found\n`
                message += 'Available types:\n'
                message += this.getAvailableTypes().join('\n')
                throw new Error(message)
            }

            if (
                (this.namespaceCache.isNamespaceCacheEmpty() && this.typeCache.isTypeCacheEmpty()) || // both caches are empty
                this.namespaceCache.isTypeAllowed(typeToReturn) || // namespace is allowed
                this.typeCache.isTypeAllowed(typeToReturn) // type is allowed
            ) {
                // continue - type is allowed
            } else {
                let allowed_namespaces = this.namespaceCache.getCachedNamespaces().join(', ')
                let allowed_types = this.typeCache.getCachedTypes().join(', ')
                throw new Error(
                    `Type ${typeToReturn.name} not allowed. \nAllowed namespaces: ${allowed_namespaces}\nAllowed types: ${allowed_types}`
                )
            }

            return typeToReturn
        } catch (error) {
            throw this.process_stack_trace(error, this.constructor.name)
        }
    }

    getAvailableTypes() {
        /** @type {string[]} */
        const availableTypes = []
        this.loadLibaryHandler.getLoadedLibraries().forEach((lib) => {
            const dynamicRequire = getRequire(import.meta.url)

            const moduleExports = dynamicRequire(`${lib}`)
            availableTypes.push(moduleExports.name)

            Object.keys(moduleExports).forEach((key) => {
                availableTypes.push(key)
            })
        })
        return availableTypes
    }
}

export { GetTypeHandler }
