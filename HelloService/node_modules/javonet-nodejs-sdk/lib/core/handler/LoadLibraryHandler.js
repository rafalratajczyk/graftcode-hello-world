// @ts-check
import { getRequire } from '../../utils/Runtime.js'
import { AbstractHandler } from './AbstractHandler.js'

/**
 * @typedef {import('../../utils/Command.js').Command} Command
 */

/** @type {typeof import('fs').existsSync | null} */
let _existsSync = null

/** @type {typeof import('path').resolve | null} */
let _resolve = null

const requireDynamic = getRequire(import.meta.url)

class LoadLibraryHandler extends AbstractHandler {
    requiredParametersCount = 1
    /** @type {string[]} */
    static loadedLibraries = []

    constructor() {
        super()
    }

    /**
     * @param {Command} command
     */
    process(command) {
        if (command.payload.length < this.requiredParametersCount) {
            throw new Error('Load Library parameters mismatch')
        }

        const { payload } = command
        const [lib] = payload

        if (!lib) {
            throw new Error('Cannot load module: Library path is required but was not provided')
        }

        if (!_existsSync) {
            const { existsSync } = requireDynamic('fs')
            _existsSync = existsSync
        }
        if (!_resolve) {
            const { resolve } = requireDynamic('path')
            _resolve = resolve
        }

        // Resolve and pick an existing path (relative or absolute)
        const absolutePath = _resolve ? _resolve(lib) : lib
        const candidatePaths = [lib, absolutePath]
        const existingPath = candidatePaths.find(p => _existsSync && _existsSync(p))

        if (!existingPath) {
            throw new Error(`Cannot load module: Library not found: ${lib}`)
        }

        // Normalize to absolute path for deduplication
        const normalizedPath = _resolve ? _resolve(existingPath) : existingPath

        // âœ… Load only once per normalized absolute path
        if (LoadLibraryHandler.loadedLibraries.includes(normalizedPath)) {
            return 0
        }

        // Derive global name from file name (using normalized path)
        const pathArray = normalizedPath.split(/[/\\]/)
        let libraryName =
            pathArray.length > 1 ? pathArray[pathArray.length - 1] : pathArray[0]
        libraryName = libraryName.replace(/\.js$/i, '')

        let moduleExports
        try {
            // Use the normalized path when requiring to keep behavior consistent
            moduleExports = requireDynamic(normalizedPath)
            LoadLibraryHandler.loadedLibraries.push(normalizedPath)
        } catch (error) {
            throw new Error('Cannot load module: ' + normalizedPath + '\n' + error)
        }

        // @ts-expect-error
        global[libraryName] = moduleExports

        for (const [key, value] of Object.entries(moduleExports)) {
            // @ts-expect-error
            global[key] = value
        }

        return 0
    }

    getLoadedLibraries() {
        return LoadLibraryHandler.loadedLibraries
    }
}

export { LoadLibraryHandler }
