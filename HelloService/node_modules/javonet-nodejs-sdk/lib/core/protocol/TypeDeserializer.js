// @ts-check
import { Command } from '../../utils/Command.js'
import { Buffer } from 'buffer'
import { StringEncodingMode } from '../../utils/StringEncodingMode.js'

export class TypeDeserializer {
    /**
     * @param {Uint8Array} encodedCommand
     * @returns {Command}
     */
    static deserializeCommand(encodedCommand) {
        return new Command(encodedCommand[0], encodedCommand[1], [])
    }

    /**
     * @param {number} stringEncodingMode
     * @param {Uint8Array} encodedString
     */
    static deserializeString(stringEncodingMode, encodedString) {
        switch (stringEncodingMode) {
            case StringEncodingMode.ASCII:
                return String.fromCharCode(...encodedString)
            case StringEncodingMode.UTF8: {
                const decoder = new TextDecoder('UTF-8')
                return decoder.decode(new Uint8Array(encodedString))
            }
            case StringEncodingMode.UTF16: {
                let str = ''
                let newBuffer = new Uint8Array(encodedString)
                for (let i = 0; i < newBuffer.length; i++) {
                    newBuffer[i] = encodedString[i]
                }
                for (let i = 0; i < encodedString.length; i = i + 2) {
                    str += String.fromCharCode(newBuffer[i] + 256 * newBuffer[i + 1])
                }
                return str
            }
            case StringEncodingMode.UTF32:
                throw 'Type utf32-encoded string not supported in JavaScript'
            default:
                throw 'Unknown string encoding - not supported in JavaScript'
        }
    }

    /**
     * @param {Uint8Array} encodedInt
     */
    static deserializeInt(encodedInt) {
        return (
            (encodedInt[0] & 0xff) |
            ((encodedInt[1] & 0xff) << 8) |
            ((encodedInt[2] & 0xff) << 16) |
            ((encodedInt[3] & 0xff) << 24)
        )
    }

    /**
     * @param {Uint8Array} encodedBool
     */
    static deserializeBool(encodedBool) {
        return encodedBool[0] === 1
    }

    /**
     * @param {Uint8Array} encodedFloat
     */
    static deserializeFloat(encodedFloat) {
        return Buffer.from(encodedFloat).readFloatLE()
    }

    /**
     * @param {Uint8Array} encodedByte
     */
    static deserializeByte(encodedByte) {
        return Buffer.from(encodedByte).readUint8()
    }

    /**
     * @param {Uint8Array} encodedChar
     */
    static deserializeChar(encodedChar) {
        return Buffer.from(encodedChar).readUint8()
    }

    /**
     * @param {Uint8Array} encodedLongLong
     */
    static deserializeLongLong(encodedLongLong) {
        return Buffer.from(encodedLongLong).readBigInt64LE()
    }

    /**
     * @param {Uint8Array} encodedDouble
     */
    static deserializeDouble(encodedDouble) {
        return Buffer.from(encodedDouble).readDoubleLE()
    }

    /**
     * @param {Uint8Array} encodedULLong
     */
    static deserializeULLong(encodedULLong) {
        return Buffer.from(encodedULLong).readBigUInt64LE()
    }

    /**
     * @param {Uint8Array} encodedUInt
     */
    static deserializeUInt(encodedUInt) {
        return Buffer.from(encodedUInt).readUIntLE(0, 4)
    }

    // eslint-disable-next-line no-unused-vars
    static deserializeNull(encodedNull = null) {
        return null
    }
}
