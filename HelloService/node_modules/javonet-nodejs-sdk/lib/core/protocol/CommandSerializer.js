// @ts-check
import { TypeSerializer } from './TypeSerializer.js'
import { ReferencesCache } from '../referenceCache/ReferencesCache.js'
import { Command } from '../../utils/Command.js'
import { CommandType } from '../../utils/CommandType.js'
import { RuntimeName } from '../../utils/RuntimeName.js'
import { TypesHandler } from '../../utils/TypesHandler.js'

/**
 * @typedef {import('../../utils/connectionData/IConnectionData.js').IConnectionData} IConnectionData
 */
class CommandSerializer {
    /**
     * Serializes the root command with connection data and optional runtime version.
     * @param {Command} rootCommand
     * @param {IConnectionData} connectionData
     * @param {number} runtimeVersion
     * @returns {Uint8Array}
     */
    static serialize(rootCommand, connectionData, runtimeVersion = 0) {
        /** @type {Array<Uint8Array>} */
        const buffers = []

        buffers.push(Uint8Array.of(rootCommand.runtimeName, runtimeVersion))

        // Write connection data or default zeros
        if (connectionData) {
            buffers.push(Uint8Array.from(connectionData.serializeConnectionData()))
        } else {
            buffers.push(Uint8Array.of(0, 0, 0, 0, 0, 0, 0))
        }

        // Write target runtime and command type
        buffers.push(Uint8Array.of(RuntimeName.Python, rootCommand.commandType))

        // Recursively serialize command and its payload
        CommandSerializer.serializeRecursively(rootCommand, buffers)

        return concatenateUint8Arrays(buffers)
    }

    /**
     * Recursively serializes command payload.
     * @param {Command} command
     * @param {Array<Uint8Array>} buffers
     */
    static serializeRecursively(command, buffers) {
        for (const item of command.payload) {
            if (item instanceof Command) {
                buffers.push(TypeSerializer.serializeCommand(item))
                CommandSerializer.serializeRecursively(item, buffers)
            } else if (TypesHandler.isPrimitiveOrNullOrUndefined(item)) {
                buffers.push(TypeSerializer.serializePrimitive(item))
            } else {
                const cachedReference = ReferencesCache.getInstance().cacheReference(item)
                const refCommand = new Command(RuntimeName.Nodejs, CommandType.Reference, cachedReference)
                buffers.push(TypeSerializer.serializeCommand(refCommand))
                CommandSerializer.serializeRecursively(refCommand, buffers)
            }
        }
    }
}

/**
 * Concatenates multiple Uint8Array buffers into one.
 * @param {Array<Uint8Array>} arrays
 * @returns {Uint8Array}
 */
function concatenateUint8Arrays(arrays) {
    let totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0)
    const result = new Uint8Array(totalLength)
    let offset = 0
    for (const arr of arrays) {
        result.set(arr, offset)
        offset += arr.length
    }
    return result
}

export { CommandSerializer }
