//@ts-check
import { getRequire, isNodejsRuntime } from '../../utils/Runtime.js'

const requireDynamic = getRequire(import.meta.url)

/** @typedef {import('ws').WebSocket} wsClient */
/** @typedef {typeof import('ws').WebSocket} WebSocketClass */

/**
 * Enum for WebSocket states.
 * @readonly
 * @enum {number}
 */
const WebSocketStateEnum = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3,
}

/**
 * Enum for WebSocket event states.
 * @readonly
 * @enum {string}
 */
const WebSocketStateEvent = {
    OPEN: 'open',
    CLOSE: 'close',
    ERROR: 'error',
    MESSAGE: 'message',
}

/** @type {WebSocketClass | null} */
let WebSocket = null

/** @type {Record<string, wsClient>} */
export const clients = {}

/** @type {Record<string, Array<{resolve: Function, reject: Function, messageArray: Uint8Array}>>} */
export const messageQueue = {}

/** @type {Record<string, boolean>} */
export const processingQueues = {}

/**
 * WebSocketClient class that handles WebSocket connection, message sending, and automatic disconnection.
 */
class WebSocketClient {
    /**
     * @param {string} url
     * @param {{ isDisconnectedAfterMessage: boolean }} options
     */
    constructor(url, options) {
        /** @type {string} */
        this.url = url
        /** @type {boolean} */
        this.isDisconnectedAfterMessage = options?.isDisconnectedAfterMessage ?? false
    }

    /** @type {wsClient | null} */
    get instance() {
        return clients[this.url] || null
    }

    get isConnected() {
        return this.instance ? this.instance?.readyState === WebSocketStateEnum.OPEN : false
    }

    /**
     * Sends messageArray through websocket connection with guaranteed order preservation
     * @async
     * @param {Uint8Array} messageArray
     * @returns {Promise<Uint8Array>}
     */
    send(messageArray) {
        return new Promise((resolve, reject) => {
            if (!messageQueue[this.url]) {
                messageQueue[this.url] = []
            }
            messageQueue[this.url].push({ resolve, reject, messageArray })

            this._processMessage()
        })
    }

    /**
     * Processes message queue sequentially to maintain order
     * @private
     * @async
     */
    async _processMessage() {
        if (processingQueues[this.url]) {
            return
        }
        processingQueues[this.url] = true

        try {
            while (messageQueue[this.url] && messageQueue[this.url].length > 0) {
                const item = messageQueue[this.url].shift()
                if (!item) break

                const { resolve, reject, messageArray } = item

                try {
                    const response = await this._send(messageArray)
                    resolve(response)
                } catch (error) {
                    reject(error)
                }
            }
        } finally {
            processingQueues[this.url] = false
        }
    }

    /**
     * Sends a single message through websocket connection
     * @private
     * @async
     * @param {Uint8Array} messageArray
     * @returns {Promise<Uint8Array>}
     */
    _send(messageArray) {
        return new Promise((resolve, reject) => {
            const client = this.instance
            if (client && this.isConnected) {
                client.send(/** @type {any} */ (messageArray))

                const messageHandler = (/** @type {any} */ message) => {
                    resolve(message)
                    if (this.isDisconnectedAfterMessage) {
                        this.disconnect()
                    }
                    client.removeListener(WebSocketStateEvent.MESSAGE, messageHandler)
                }
                client.on(WebSocketStateEvent.MESSAGE, messageHandler)
            } else {
                this._connect()
                    .then((client) => {
                        client.send(/** @type {any} */ (messageArray))
                        const messageHandler = (/** @type {any} */ message) => {
                            resolve(message)
                            if (this.isDisconnectedAfterMessage) {
                                this.disconnect()
                            }
                            client.removeListener(WebSocketStateEvent.MESSAGE, messageHandler)
                        }
                        client.on(WebSocketStateEvent.MESSAGE, messageHandler)
                    })
                    .catch(reject)
            }
        })
    }

    /**
     * Disconnects the WebSocket by terminating the connection and cleans up queues.
     */
    disconnect() {
        if (this.instance) {
            this.instance.close()
            delete clients[this.url]
        }

        // Clean up message queue and processing state
        if (messageQueue[this.url]) {
            // Reject any pending messages
            messageQueue[this.url].forEach(({ reject }) => {
                reject(new Error('WebSocket disconnected'))
            })
            delete messageQueue[this.url]
        }

        delete processingQueues[this.url]
    }

    /**
     * Connects to the WebSocket server.
     * @private
     * @async
     * @returns {Promise<wsClient>} - A promise that resolves when the connection is established.
     */
    _connect() {
        if (!WebSocket && isNodejsRuntime()) {
            try {
                WebSocket = requireDynamic('ws')
            } catch (error) {
                if (/** @type {{ code?: string }} */ (error).code === 'MODULE_NOT_FOUND') {
                    throw new Error('ws module not found. Please install it using npm install ws')
                }
                throw error
            }
        }

        return new Promise((resolve, reject) => {
            if (!WebSocket) {
                return reject(new Error('ws client is null'))
            }

            let client = clients[this.url]
            if (!client) {
                client = new WebSocket(this.url)
                clients[this.url] = client
            }

            client.on(WebSocketStateEvent.OPEN, () => resolve(client))
            client.on(WebSocketStateEvent.ERROR, (/** @type {unknown} */ error) => reject(error))
            client.on(WebSocketStateEvent.CLOSE, () => {
                reject(new Error('Connection closed before receiving message'))
            })
        })
    }
}

export { WebSocketClient }
