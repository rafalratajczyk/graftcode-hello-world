// @ts-check
import { isBrowserRuntime } from '../../utils/Runtime.js'

const WebSocketState = /** @type {const} */ ({
    OPEN: 'open',
    CLOSE: 'close',
    ERROR: 'error',
    MESSAGE: 'message',
})

/**
 * @type {typeof WebSocket | null}
 */
let WsClient = null

if (isBrowserRuntime()) {
    WsClient = WebSocket
}

/**
 * @typedef {object} Options
 * @property {boolean} [isDisconnectedAfterMessage]
 */

/** @type {Record<string, WebSocket>} */
export const clients = {}

/** @type {Record<string, Array<{resolve: Function, reject: Function, messageArray: Uint8Array}>>} */
export const messageQueue = {}

/** @type {Record<string, boolean>} */
export const processingQueues = {}

/**
 * WebSocketClient class that handles WebSocket connection, message sending, and automatic disconnection.
 */
class WebSocketClientBrowser {
    /**
     * @param {string} url
     * @param {Options} [options]
     */
    constructor(url, options) {
        /** @type {string} */
        this.url = url

        /** @type {boolean} */
        this.isDisconnectedAfterMessage = options?.isDisconnectedAfterMessage ?? false
    }

    /** @type {WebSocket | null} */
    get instance() {
        return clients[this.url] || null
    }

    get isConnected() {
        return this.instance ? this.instance.readyState === WebSocket.OPEN : false
    }

    /**
     * Sends messageArray through websocket connection with guaranteed order preservation
     * @async
     * @param {Uint8Array} messageArray
     * @returns {Promise<Uint8Array>}
     */
    send(messageArray) {
        return new Promise((resolve, reject) => {
            if (!messageQueue[this.url]) {
                messageQueue[this.url] = []
            }
            messageQueue[this.url].push({ resolve, reject, messageArray })

            this._processMessage()
        })
    }

    /**
     * Processes message queue sequentially to maintain order
     * @private
     * @async
     */
    async _processMessage() {
        if (processingQueues[this.url]) {
            return
        }
        processingQueues[this.url] = true

        try {
            while (messageQueue[this.url] && messageQueue[this.url].length > 0) {
                const item = messageQueue[this.url].shift()
                if (!item) break

                const { resolve, reject, messageArray } = item
                try {
                    const response = await this._sendSingle(messageArray)
                    resolve(response)
                } catch (error) {
                    reject(error)
                }
            }
        } finally {
            processingQueues[this.url] = false
        }
    }

    /**
     * Sends a single message through websocket connection
     * @private
     * @async
     * @param {Uint8Array} messageArray
     * @returns {Promise<Uint8Array>}
     */
    _sendSingle(messageArray) {
        return new Promise((resolve, reject) => {
            const client = this.instance
            if (client && this.isConnected) {
                this._sendMessage(client, messageArray, resolve, reject)
            } else {
                this._connect()
                    .then((ws) => {
                        this._sendMessage(ws, messageArray, resolve, reject)
                    })
                    .catch(reject)
            }
        })
    }

    /**
     * Disconnects the WebSocket by terminating the connection and cleans up queues.
     */
    disconnect() {
        const client = this.instance
        if (client) {
            client.close()
            delete clients[this.url]
        }

        if (messageQueue[this.url]) {
            messageQueue[this.url].forEach(({ reject }) => {
                reject(new Error('WebSocket disconnected'))
            })
            delete messageQueue[this.url]
        }
        delete processingQueues[this.url]
    }

    /**
     * Connects to the WebSocket server.
     * @private
     * @async
     * @returns {Promise<WebSocket>}
     */
    _connect() {
        return new Promise((resolve, reject) => {
            if (!WsClient) {
                return reject(new Error('missing WebSocket client'))
            }

            let client = clients[this.url]
            if (!client) {
                client = new WsClient(this.url)
                client.binaryType = 'arraybuffer'
                clients[this.url] = client
            }

            client.addEventListener(WebSocketState.OPEN, () => resolve(client))
            client.addEventListener(WebSocketState.ERROR, reject)
            client.addEventListener(WebSocketState.CLOSE, () => {
                reject(new Error('Connection closed before receiving message'))
            })
        })
    }

    /**
     * Sends the data to the WebSocket server and listens for a response.
     * @private
     * @param {WebSocket} client
     * @param {Uint8Array} data
     * @param {(value: Uint8Array) => void} resolve
     * @param {(reason?: any) => void} reject
     */
    _sendMessage(client, data, resolve, reject) {
        try {
            const arrayBuffer = data.buffer
            client.send(arrayBuffer)

            const handleMessage = (/** @type {any} */ message) => {
                if (!message?.data) {
                    return reject(new Error('Invalid message received'))
                }

                const byteArray = new Uint8Array(message?.data)
                resolve(byteArray)

                if (this.isDisconnectedAfterMessage) {
                    this.disconnect()
                }

                client.removeEventListener(WebSocketState.MESSAGE, handleMessage)
                client.removeEventListener(WebSocketState.ERROR, handleError)
            }

            const handleError = (/** @type {unknown} */ error) => {
                reject(error)

                client.removeEventListener(WebSocketState.MESSAGE, handleMessage)
                client.removeEventListener(WebSocketState.ERROR, handleError)
            }

            client.addEventListener(WebSocketState.MESSAGE, handleMessage)
            client.addEventListener(WebSocketState.ERROR, handleError)
        } catch (err) {
            reject(err)
        }
    }
}

export { WebSocketClientBrowser }
