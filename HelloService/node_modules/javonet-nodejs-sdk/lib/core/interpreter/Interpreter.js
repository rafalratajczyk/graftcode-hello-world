// @ts-check
import { ConnectionType } from '../../utils/ConnectionType.js'
import { isNodejsRuntime, getRequire } from '../../utils/Runtime.js'
import { RuntimeName } from '../../utils/RuntimeName.js'
import { CommandDeserializer } from '../protocol/CommandDeserializer.js'
import { CommandSerializer } from '../protocol/CommandSerializer.js'
import { TransmitterWebsocketBrowser } from '../transmitter/TransmitterWebsocketBrowser.js'
import { TransmitterWebsocket } from '../transmitter/TransmitterWebsocket.js'
import { Handler } from '../handler/Handler.js'

/**
 * @typedef {import('../../utils/connectionData/IConnectionData.js').IConnectionData} IConnectionData
 * @typedef {typeof import('../../types.d.ts').RuntimeName} RuntimeNameType
 * @typedef {import('../../utils/Command.js').Command} Command
 */

/** @type {typeof import('../receiver/Receiver.js').Receiver} */
let _Receiver
/** @type {typeof import('../transmitter/Transmitter.js').Transmitter} */
let _Transmitter
/** @type {typeof import('../transmitter/TransmitterWebsocket.js').TransmitterWebsocket | typeof import('../transmitter/TransmitterWebsocketBrowser.js').TransmitterWebsocketBrowser} */
let _TransmitterWebsocket = isNodejsRuntime() ? TransmitterWebsocket : TransmitterWebsocketBrowser

const requireDynamic = getRequire(import.meta.url)

export class Interpreter {

    /**
     *
     * @param {Command} command
     * @param {IConnectionData} connectionData
     * @returns {Promise<Command>}
     */
    static async execute(command, connectionData) {
        try {
            let messageByteArray = CommandSerializer.serialize(command, connectionData)

            if (!(messageByteArray instanceof Uint8Array)) {
                throw new Error('Serialized message is not Uint8Array')
            }

            /** @type {Promise<Uint8Array> | Uint8Array | undefined} */
            let responseByteArray = undefined

            if (!isNodejsRuntime() && connectionData.connectionType === ConnectionType.IN_MEMORY) {
                throw new Error(
                    'Nodejs Core Error: inMemory is only allowed in Nodejs runtime, not in browser'
                )
            }

            if (
                command.runtimeName === RuntimeName.Nodejs &&
                connectionData.connectionType === ConnectionType.IN_MEMORY
            ) {
                if (!_Receiver) {
                    const { Receiver } = requireDynamic('../receiver/Receiver.js')
                    _Receiver = Receiver
                }
                if (!_Receiver) {
                    throw new Error('Nodejs Core Error: Receiver is undefined')
                }
                responseByteArray = await _Receiver.sendCommand(messageByteArray)
            } else if (
                connectionData.connectionType === ConnectionType.IN_MEMORY ||
                connectionData.connectionType === ConnectionType.TCP
            ) {
                if (!_Transmitter) {
                    const { Transmitter } = requireDynamic('../transmitter/Transmitter.js')
                    _Transmitter = Transmitter
                }
                if (!_Transmitter) {
                    throw new Error('Nodejs Core Error: Transmitter is undefined')
                }
                responseByteArray = await _Transmitter.sendCommand(messageByteArray)
            } else if (connectionData.connectionType === ConnectionType.WEB_SOCKET) {
                responseByteArray = await _TransmitterWebsocket.sendCommand(messageByteArray, connectionData)
            }

            if (!responseByteArray) {
                throw new Error('No response received from Transmitter')
            }
            return new CommandDeserializer(responseByteArray).deserialize()
        } catch (error) {
            throw error
        }
    }

    /**
     *
     * @param {Uint8Array} messageByteArray
     * @returns {Promise<Command> | Command}
     */
    static process(messageByteArray) {
        try {
            const receivedCommand = new CommandDeserializer(messageByteArray).deserialize()
            return Handler.handleCommand(receivedCommand)
        } catch (error) {
            throw error
        }
    }
}
