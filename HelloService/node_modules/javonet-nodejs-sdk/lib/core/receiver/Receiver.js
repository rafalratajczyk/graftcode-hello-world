// @ts-check
import { CommandSerializer } from '../protocol/CommandSerializer.js'
import { InMemoryConnectionData } from '../../utils/connectionData/InMemoryConnectionData.js'
import { ExceptionSerializer } from '../../utils/exception/ExceptionSerializer.js'
import { Command } from '../../utils/Command.js'
import { CommandType } from '../../utils/CommandType.js'
import { RuntimeName } from '../../utils/RuntimeName.js'
import { RuntimeLogger } from '../../utils/RuntimeLogger.js'
import { Interpreter } from './../interpreter/Interpreter.js'

export class Receiver {
    static connectionData = new InMemoryConnectionData()

    static getRuntimeInfo() {
        return RuntimeLogger.getRuntimeInfo()
    }

    /**
     * @param {Uint8Array} messageByteArray
     * @returns {Promise<Uint8Array>}
     */
    static async sendCommand(messageByteArray) {
        try {
            let command = await Interpreter.process(messageByteArray)
            return CommandSerializer.serialize(command, this.connectionData)
        } catch (error) {
            const exceptionCommand = ExceptionSerializer.serializeException(
                error,
                new Command(RuntimeName.Nodejs, CommandType.Exception, [])
            )
            return CommandSerializer.serialize(exceptionCommand, this.connectionData)
        }
    }

    /**
     * @param {Uint8Array} messageByteArray
     * @returns {Promise<Uint8Array>}
     */
    static async heartBeat(messageByteArray) {
        let response = new Uint8Array(2)
        response[0] = messageByteArray[11]
        response[1] = messageByteArray[12] - 2
        return Promise.resolve(response)
    }
}
